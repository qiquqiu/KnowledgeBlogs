<p></p><br><div class="toc"><br> <h4>文章目录</h4><br> <ul><li><a href="#__3">一、 题目描述</a></li><li><a href="#___01_21">二、 核心思路 - “0”变“-1”</a></li><li><a href="#__33">三、 从“子数组和”到“前缀和”</a></li><li><a href="#__45">四、 哈希表的妙用</a></li><li><a href="#__61">五、 代码实现</a></li><li><ul><li><a href="#_98">执行用时情况</a></li></ul><br>  </li><li><a href="#__104">六、 关键点与复杂度分析</a></li></ul><br></div><br><br /> <br><a href="https://leetcode.cn/problems/contiguous-array/description/" rel="nofollow">LeetCode 525 (连续数组)</a>，【难度：中等；通过率：55.2%】，这道题的巧妙之处在于，它需要我们先对问题进行一次思维的转变，然后才能套用我们熟悉的算法模型<br><p></p> <br><h2><a id="__3"></a>一、 题目描述</h2> <br><p>给定一个二进制数组 <code>nums</code>，找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度</p> <br><p><strong>示例:</strong></p> <br><pre><code>输入: nums = [0,1]<br>输出: 2<br>解释: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组<br><br>输入: nums = [0,1,0]<br>输出: 2<br>解释: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组<br></code></pre> <br><hr /> <br><h2><a id="___01_21"></a>二、 核心思路 - “0”变“-1”</h2> <br><p>题目的要求是“相同数量的 0 和 1”。直接处理计数会比较复杂。这里有一个非常关键的思想转换：</p> <br><p><strong>如果我们将数组中所有的 <code>0</code> 都看作 <code>-1</code>，那么“0 和 1 数量相等”就等价于“子数组所有元素之和为 0”。</strong></p> <br><p>为什么呢？假设一个子数组中有 <code>k</code> 个 <code>1</code> 和 <code>k</code> 个 <code>0</code>。经过转换后，这个子数组就变成了 <code>k</code> 个 <code>1</code> 和 <code>k</code> 个 <code>-1</code>。它们的和自然就是 <code>k * 1 + k * (-1) = 0</code></p> <br><p>通过这个转换，问题就从“找到含有相同数量 0 和 1 的最长连续子数组”，变成了“<strong>找到和为 0 的最长连续子数组</strong>”。这是一个我们非常熟悉的前缀和问题！</p> <br><hr /> <br><h2><a id="__33"></a>三、 从“子数组和”到“前缀和”</h2> <br><p>现在问题是找到和为 0 的最长子数组。我们知道，一个从索引 <code>i</code>到 <code>j</code> 的子数组的和 <code>sum(i, j)</code> 可以通过前缀和数组 <code>P</code> 来计算：</p> <br><p><code>sum(i, j) = P[j] - P[i-1]</code></p> <br><p>我们希望 <code>sum(i, j) == 0</code>，这也就意味着 <code>P[j] == P[i-1]</code></p> <br><p>所以，问题再次被转换为：<strong>找到两个索引 <code>i-1</code> 和 <code>j</code>，使得它们对应的前缀和相等，并求出所有这种情况中 <code>j - (i-1)</code> 的最大值。</strong></p> <br><hr /> <br><h2><a id="__45"></a>四、 哈希表的妙用</h2> <br><p>为了高效地找到之前出现过的相同的前缀和，哈希表是我们的不二之选</p> <br><ul><li><strong>Key</strong>: 前缀和的值</li><li><strong>Value</strong>: 该前缀和<strong>第一次</strong>出现的索引</li></ul> <br><p>我们只需要记录第一次出现的索引，因为对于一个固定的终点 <code>j</code>，起点 <code>i-1</code> 的索引越小，子数组的长度 <code>j - (i-1)</code> 就越大</p> <br><p><strong>一个关键的初始化</strong>：我们需要在哈希表中预先放入 <code>map.put(0, -1)</code>。这有什么用呢？它用于处理那些从数组开头 <code>index=0</code> 开始的子数组。例如，如果 <code>nums = [0, 1]</code>，转换后为 <code>[-1, 1]</code></p> <br><ul><li>当 <code>i=0</code> 时，前缀和为 <code>-1</code></li><li>当 <code>i=1</code> 时，前缀和为 <code>-1 + 1 = 0</code>。此时，我们在哈希表中查找 <code>0</code>，找到了它在索引 <code>-1</code> 处。子数组长度为 <code>1 - (-1) = 2</code>，这正是正确答案</li></ul> <br><hr /> <br><h2><a id="__61"></a>五、 代码实现</h2> <br><p>这就是我们将上述所有思路融合在一起的最终代码</p> <br><pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaxLength</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 1. 使用 HashMap 存储 <前缀和, 第一次出现的索引></span><br>        <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <br>        <span class="token comment">// 2. 关键初始化：处理从数组开头开始的子数组</span><br>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <br>        <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> currentSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 动态计算的前缀和</span><br><br>        <span class="token comment">// 3. 一次遍历完成所有操作</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token comment">// a. 将 0 视为 -1，动态更新前缀和</span><br>            currentSum <span class="token operator">+=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>            <span class="token comment">// b. 检查当前前缀和是否已存在于 map 中</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>currentSum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token comment">// 如果存在，说明找到了一个和为 0 的子数组</span><br>                <span class="token comment">// 长度为 i - map.get(currentSum)</span><br>                maxLength <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxLength<span class="token punctuation">,</span> i <span class="token operator">-</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>currentSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token comment">// c. 如果是第一次出现，记录其索引</span><br>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currentSum<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token keyword">return</span> maxLength<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><h3><a id="_98"></a>执行用时情况</h3> <br><p><img src="https://i-blog.csdnimg.cn/direct/41148c7e60dd4f19a5ad3471d1b37939.png" alt="外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传" /></p> <br><hr /> <br><h2><a id="__104"></a>六、 关键点与复杂度分析</h2> <br><ul><li><strong>思想转换</strong>：将“数量相等”问题转化为“和为 0”问题是解题的钥匙</li><li><strong>前缀和 + 哈希表</strong>：这是解决各类子数组和问题的标准、高效模式，必须熟练掌握</li><li><strong>边界处理</strong>：<code>map.put(0, -1)</code> 的初始化是确保算法正确性的关键细节</li><li><strong>时间复杂度</strong>：<strong>O(N)</strong> 我们只需要对数组进行一次遍历，哈希表的插入和查找操作平均时间复杂度为 O(1)</li><li><strong>空间复杂度</strong>：<strong>O(N)</strong> 在最坏的情况下（例如，数组中全是 1），每个前缀和都不同，哈希表需要存储 N 个条目</li></ul>