# 【集合篇01】：ArrayList和LinkedList的详细对比

> 原创 于 2025-07-06 08:45:00 发布 · 公开 · 915 阅读 · 16 · 20 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149143249

**文章目录**

[TOC]



## 1. 底层数据结构

这是 `ArrayList` 和 `LinkedList` 最本质的区别

-  **ArrayList:** `ArrayList` 底层是基于 **动态数组** 实现的这意味着它内部维护着一个连续的内存空间来存储元素当元素数量超出当前数组容量时， `ArrayList` 会进行扩容操作，创建一个更大的新数组，并将原有元素复制过去

-  **LinkedList:** `LinkedList` 底层是基于 **双向链表** 实现的链表中的每个节点都包含三部分信息：存储的数据、指向前一个节点的指针以及指向后一个节点的指针节点之间通过指针相互连接，内存空间可以是不连续的

---

## 2. 操作数据效率

不同的底层数据结构决定了它们在各种操作上的效率差异

-  **查询（已知索引）：** 

  -  `ArrayList` : 由于底层是数组，内存连续，可以通过数组下标直接访问元素根据寻址公式，访问任意位置元素的时间复杂度是 **O(1)** ，效率非常高

  -  `LinkedList` : 不支持直接通过下标访问元素要访问某个位置的元素，需要从链表头部或尾部开始遍历，直到找到目标位置因此，查询（已知索引）的时间复杂度是 **O(n)** 

-  **查找（未知索引）：** 

  -  `ArrayList` : 需要遍历数组，逐个比较元素时间复杂度是 **O(n)** 

  -  `LinkedList` : 需要遍历链表，逐个比较节点时间复杂度也是 **O(n)** 

-  **新增和删除：** 

  -  `ArrayList` :

    - 在 **尾部** 插入或删除元素：由于只需要在数组末尾进行操作，无需移动其他元素，时间复杂度是 **O(1)** 

    - 在 **其他位置** 插入或删除元素：需要移动被插入/删除位置之后的所有元素来保持数组的连续性最坏情况下（在头部操作），需要移动所有元素，时间复杂度是 **O(n)** 

  -  `LinkedList` :

    - 在 **头部或尾部** 插入或删除节点：只需要修改少数节点的指针，时间复杂度是 **O(1)** 

    - 在 **其他位置** 插入或删除节点：需要先遍历链表找到目标位置，然后修改前后节点的指针查找目标位置的时间复杂度是 O(n)，修改指针的时间复杂度是 O(1)，因此总的时间复杂度是 **O(n)** 

---

## 3. 内存空间占用

底层结构的差异也体现在内存占用上

-  **ArrayList:** 底层是数组，内存是连续的，相对来说比较紧凑，节省内存

-  **LinkedList:** 每个节点除了存储数据本身，还需要存储指向前一个节点和后一个节点的两个指针这些指针会额外占用内存空间，因此 `LinkedList` 相对于 `ArrayList` 会更占用内存

---

## 4. 线程安全

`ArrayList` 和 `LinkedList` 本身都不是线程安全的在多线程环境下，如果多个线程同时对同一个 `ArrayList` 或 `LinkedList` 进行修改操作，可能会导致数据不一致或产生其他不可预测的行为

如果需要在多线程环境下使用线程安全的列表，有以下几种方案：

-  **局部变量：** 如果 `ArrayList` 或 `LinkedList` 是在方法内部创建并使用的局部变量，那么它是线程安全的，因为每个线程都有自己的方法栈和局部变量副本

-  **使用线程安全的实现：** Java 提供了线程安全的列表实现，例如 `Vector` (已不推荐使用) 或者通过 `Collections.synchronizedList()` 方法将非线程安全的列表包装成线程安全的例如： `List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>());` 

---

## 总结

下表总结了 `ArrayList` 和 `LinkedList` 的主要区别：

| 特性 | ArrayList | LinkedList |
|:---|:---|:---|
| 底层数据结构 | 动态数组 | 双向链表 |
| 查询 (已知索引) | O(1) | O(n) |
| 查询 (未知索引) | O(n) | O(n) |
| 尾部增删 | O(1) | O(1) |
| 其他位置增删 | O(n) | O(n) (查找 O(n) + 修改指针 O(1)) |
| 内存占用 | 相对较少 | 相对较多 (需要存储指针) |
| 线程安全 | 非线程安全 | 非线程安全 |
| 线程安全方案 | 局部变量、 `Collections.synchronizedList()`  | 局部变量、 `Collections.synchronizedList()`  |


**何时选择 ArrayList？** 

> 

- 需要频繁地通过索引访问或查询元素

- 对内存空间占用比较敏感

- 主要在列表尾部进行添加或删除操作

**何时选择 LinkedList？** 

> 

- 需要频繁地在列表的头部或尾部进行添加或删除操作

- 对元素的插入和删除操作比较多，且不关心通过索引访问的效率

