# 【多线程篇23】：详解ConcurrentHashMap的put()方法四种场景

> 原创 于 2025-07-23 08:15:00 发布 · 公开 · 716 阅读 · 27 · 10 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149551733

**文章目录**

[TOC]



## 前提：ConcurrentHashMap 的基本工具

1.  **`volatile`** ：相当于一个“广播系统”。当 `table` 数组（货架）发生变化（比如换了个新货架），或者某个货位上的物品信息（ `Node` 的值和下一个物品的指向）更新时， `volatile` 能确保所有线程都能立刻看到最新的状态，避免信息不一致。

2.  **`CAS` (Compare-And-Swap)** ：可以理解为一种“ **乐观的尝试** ”。它包含三个参数： `CAS(内存地址, 期望值, 新值)` 。

   -  **操作** ：它会先检查“内存地址”上的值是否等于“期望值”。

   -  **结果** ：

     -  **如果相等** ，说明在它检查期间没有其他线程修改过，它就放心地把“新值”放上去，操作成功。

     -  **如果不相等** ，说明有其他线程“捷足先登”了，它的操作就失败， **但不会阻塞** ，而是立即返回失败。
        `CAS` 是原子性的，由 CPU 指令保证。CHM 中类似 `casTabAt()` 这样的方法就是 `CAS` 的封装。

3.  **`synchronized` 锁** ：这是最后的“杀手锏”。当 `CAS` 搞不定时，就用 `synchronized` 这把“锁”来强制排队，保证同一时间只有一个线程能操作某个区域。

---

##  `put` 操作的四种并发场景及应对策略

当一个线程 T1 调用 `put(key, value)` 时，它会进入一个 `for` 无限循环，根据不同情况采取不同策略，直到成功为止。

### 场景一：整个 Map 还是空的（首次 `put` ）

**情况描述** ：
T1 是第一个来存东西的线程，发现 `table` 数组（货架）根本还没建好 ( `table == null` )。这时，可能有多个线程同时发现货架是空的，都想来搭建。

**并发风险** ：
如果不加控制，多个线程可能会造出多个不同的货架，造成混乱。

**CHM 的解决方案： `CAS` 初始化** 

- CHM 不会直接 `new` 一个数组，而是调用 `initTable()` 方法。

- 在这个方法内部，会使用一个 `CAS` 操作来竞争“建造权”。

- 所有想建货架的线程都会去尝试 `CAS` 一个叫 `sizeCtl` 的状态变量。只有第一个成功将 `sizeCtl` 从 0 改为 -1 的线程才能真正去 `new` 数组。

-  **结果** ：其他 `CAS` 失败的线程会发现“建造中”，它们不会参与建造，而是会原地自旋（ `yield` ）一下，等待那个“幸运儿”把货架建好。这样就保证了 **`table` 数组只被初始化一次** 。

### 场景二：要放入的桶（数组位置）是空的

**情况描述** ：
货架已经建好。线程 T1 计算出 `key` 应该放在 `table[i]` 这个位置，并且发现这个位置是空的 ( `null` )。

**并发风险** ：
在 T1 准备把新节点放进去的瞬间，另一个线程 T2 也计算出要放在 `table[i]` ，也发现是空的，两个线程可能同时写入，导致 T1 的数据被 T2 覆盖（数据丢失）。

**CHM 的解决方案： `CAS` 占位** 

- T1 **不会直接** `table[i] = newNode` ，而是使用 `casTabAt(tab, i, null, newNode)` 方法。

- 这个 `CAS` 操作的意思是：“我期望 `table[i]` 是 `null` ，如果是，我就把它变成我的新节点 `newNode` 。”

-  **如果成功** ：说明在 T1 操作期间没有其他线程捣乱，T1 成功占位， `put` 操作完成，跳出循环。这是 **最高效、无锁** 的插入方式。

-  **如果失败** ：说明就在刚刚，T2 抢先一步把一个节点放了进去。T1 的 `CAS` 会失败，但它不会报错或阻塞。 `for` 循环会继续，T1 会重新读取 `table[i]` 的新值（T2 刚放进去的节点），然后进入 **场景四** 的处理流程。

### 场景三：Map 正在扩容

**情况描述** ：
T1 计算出 `key` 应该放在 `table[i]` ，但它发现 `table[i]` 里面放的不是一个普通的数据节点，而是一个特殊的 `ForwardingNode` 。这个特殊节点像个“搬家告示”，告诉所有来的线程：“我们正在搬家（扩容），别在这里放东西了！”

**并发风险** ：
如果在扩容期间还允许线程往旧货架上放东西，会导致数据混乱和丢失。

**CHM 的解决方案：协同扩容** 

- T1 看到“搬家告示”后， **不会傻等** ，而是会主动加入“搬家大队”，调用 `helpTransfer()` 方法帮助其他线程一起把旧货架上的数据迁移到新货架上。

-  **优点** ：人多力量大！通过让所有遇到扩容的线程都参与进来，可以大大加快扩容速度。

- 搬完家后，T1 的 `for` 循环会用新的 `table` 数组继续尝试 `put` 操作。

### 场景四：要放入的桶里已经有数据了（哈希冲突）

**情况描述** ：
T1 发现 `table[i]` 这个桶里已经有节点了（可能是链表或红黑树），它需要把自己的新节点加到这个链表或树的末尾，或者更新链表中已有的同名 `key` 。

**并发风险** ：
多个线程可能同时在修改 **同一个链表** ，比如 T1 准备在节点 A 后面接上自己的节点 C，同时 T2 也准备在节点 A 后面接上自己的节点 D，这会造成链表结构错乱和数据丢失。

**CHM 的解决方案： `synchronized` 锁住桶的头节点** 

- 这是 `CAS` 无法解决的复杂场景，于是 CHM 拿出了“杀手锏”—— `synchronized` 。

- 但它并 **不锁住整个 `table` 数组** ，那样效率太低了。

- 它只 `synchronized(f)` ，其中 `f` 就是 `table[i]` 这个桶的 **头节点** 。

-  **效果** ：

  - 任何想修改 `table[i]` 这个桶的线程，都必须先获得 `f` 这个对象的锁。

  - 这意味着，在同一时刻， **只有一个线程能修改 `table[i]` 桶内的链表或红黑树** ，保证了操作的原子性。

  - 而其他线程如果想操作 **不同** 的桶，比如 `table[j]` ，它们完全不受影响，因为它们锁的是 `table[j]` 的头节点，锁的对象不同，可以 **并行执行** 。

**这就是 CHM 高并发性能的关键：锁的粒度非常细，只在真正需要排队的地方（修改同一个桶）才加锁，其他所有情况都尽可能地无锁或并行执行。** 

---

## 总结

| 并发情况 |  `HashMap` 的做法 |  `ConcurrentHashMap` 的智能应对 | 使用的“法宝” |
|:---|:---|:---|:---|
|  **首次 `put` ，初始化 `table`**  | 直接 `new` ，多线程下会重复创建 | 只有一个线程能成功创建，其他等待 |  `CAS`  |
|  **目标桶为空**  | 直接赋值，并发下数据会被覆盖 | 尝试原子性地占位，失败则重试 |  `CAS`  |
|  **目标桶已有数据（哈希冲突）**  | 直接修改链表，并发下链表错乱 |  **锁住这个桶的头节点** ，排队修改 |  `synchronized`  |
|  **Map 正在扩容**  | 单线程扩容，并发下会出严重问题 | 所有遇到扩容的线程都一起帮忙 | - |
|  **读取数据 ( `get` )**  | 无保护，可能读到中间状态的脏数据 | 无需加锁，直接读取 |  `volatile`  |