# 【多线程篇10】：详解java乐观锁的基本实现方式及其与悲观锁的对比

> 原创 已于 2025-07-14 08:54:31 修改 · 公开 · 1.1k 阅读 · 33 · 29 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149322681

**文章目录**

[TOC]


在多线程编程中，如何优雅地处理共享资源的并发访问，是衡量一位后端工程师内功深浅的重要标尺。为了解决线程安全问题，引入了“锁”的概念。然而，锁的实现并非只有一种思路，其背后蕴含着两种截然不同的哲学思想： **悲观主义** 和 **乐观主义** 

## 1.悲观锁：未雨绸缪，先锁再说

> “对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁”

悲观锁的哲学非常直接：它假设并发冲突总是会发生。因此，为了绝对安全，在对数据进行任何操作之前，它会先获取一个 **排他锁** ，确保在自己操作期间，没有其他线程可以访问该数据。操作完成后，再释放锁

**Java 中的典型代表： `synchronized` 和 `ReentrantLock`** 

`synchronized` 关键字就是悲观锁最经典的实现。无论当前是否存在竞争，它都会先尝试加锁

```java
public class PessimisticCounter {
    private int count = 0;

    // 每次调用此方法，都会先获取当前对象的锁
    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

-  **优点** ：实现简单，逻辑清晰，能确保数据在任何情况下的强一致性

-  **缺点** ：如果并发冲突的概率很低，加锁和释放锁的开销（包括线程阻塞和上下文切换）会成为不必要的性能负担，导致系统吞吐量下降

---

## 2. 乐观锁：大胆尝试，冲突再议

> “对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑”

乐观锁则完全相反。它假设并发冲突是小概率事件。因此，它不会在操作前加锁，而是直接去操作数据。在 **提交更新** 的时候，它会检查一下，在自己操作期间，数据是否被其他线程修改过

- 如果 **没有被修改** ，则成功提交更新

- 如果 **已经被修改** ，则认为发生了冲突，更新失败。此时，通常会进行重试（重新读取数据、执行操作、尝试提交），或者直接放弃

这种“检查并更新”的机制，就是乐观锁的核心

---

## 3. Java 中实现乐观锁的三种方式

基于乐观锁的思想和 CAS 的能力，我们在 Java 中有多种实现方式

### 方式一：使用原子类（基于 CAS）

详细实现参考： [【多线程篇09】：一文看懂CAS技术与乐观锁思想](https://blog.csdn.net/lyh2004_08/article/details/149307798) 

这是最直接、最常用的方式。 `java.util.concurrent.atomic` 包提供了一系列原子类，如 `AtomicInteger` 、 `AtomicLong` 、 `AtomicReference` 等，它们内部就是通过 CAS 来实现无锁的线程安全操作

```java
import java.util.concurrent.atomic.AtomicInteger;

public class OptimisticCounter {
    // 使用 AtomicInteger 替代普通的 int
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        // incrementAndGet() 内部就是一个 CAS 自旋循环
        // 不断尝试将当前值 +1，直到成功为止
        count.incrementAndGet();
    }

    public int getCount() {
        return count.get();
    }
}
```

在 `incrementAndGet()` 内部，线程会不断地读取当前值，计算新值，然后通过 CAS 尝试更新。如果失败（说明有其他线程抢先修改了），它会再次循环，直到成功。这个过程被称为“自旋”，它避免了线程的阻塞

### 方式二：版本号（Version）机制

这是在数据库和业务系统中非常常用的一种乐观锁实现

**原理** ：在数据表中增加一个 `version` 字段（通常是数字类型）

1.  **读取数据** ：当读取数据时，将 `version` 字段的值一并读出
    `SELECT value, version FROM my_table WHERE id = 1;` 

2.  **更新数据** ：当提交更新时，将之前读到的 `version` 值作为条件。同时，将 `version` 值加 1
    `UPDATE my_table SET value = 'new_value', version = version + 1 WHERE id = 1 AND version = 123;` 

- 如果更新成功（影响行数为 1），说明在你操作期间没有其他线程修改过数据

- 如果更新失败（影响行数为 0），说明 `version` 已经被其他线程修改，发生了冲突。此时，应用层需要根据业务逻辑决定是重试还是放弃

许多 ORM 框架（如 JPA/Hibernate）都内置了 `@Version` 注解来自动支持此功能

### 方式三：时间戳（Timestamp）机制

原理与版本号机制类似，只是将 `version` 字段换成了一个 `timestamp` 字段，记录数据的最后更新时间

**更新逻辑** ： `UPDATE my_table SET value = 'new_value', timestamp = 'current_time' WHERE id = 1 AND timestamp = 'old_time';` 

虽然可行，但时间戳机制的精度和可靠性不如版本号机制。例如，在分布式系统中可能存在时钟不同步的问题，导致判断出错。因此， **版本号机制通常是更推荐的选择** 

---

## 总结：如何选择悲观锁与乐观锁？

| 特性 | 悲观锁 ( `synchronized` ) | 乐观锁 (CAS / Version) |
|:---|:---|:---|
|  **哲学**  | 总是假设冲突会发生 | 总是假设冲突不会发生 |
|  **冲突处理**  | 加锁，阻塞其他线程 | 不加锁，冲突时重试或失败 |
|  **开销**  | 线程阻塞、上下文切换开销大 | 重试逻辑开销（CPU消耗） |
|  **适用场景**  |  **写多读少** ，并发冲突概率高 |  **读多写少** ，并发冲突概率低 |
|  **性能**  | 冲突严重时，性能稳定 | 冲突少时，性能高；冲突严重时，重试导致性能下降 |


**选择建议：** 

-  **选择悲观锁** ：当知道并发写入的冲突会非常频繁，且临界区的执行时间很短时。悲观锁可以避免乐观锁在高度竞争下的大量重试开销

-  **选择乐观锁** ：当应用是“读多写少”的类型，并发冲突的概率较低时。乐观锁可以避免加锁带来的性能损耗，提高系统的吞吐量

