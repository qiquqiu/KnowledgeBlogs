# 【多线程篇24】：深入理解并发编程的“三座大山”：原子性、可见性与有序性

> 原创 于 2025-07-23 09:56:15 发布 · 公开 · 910 阅读 · 25 · 6 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149562042

**文章目录**

[TOC]


与并发相伴而生的往往是各种难以捉摸的Bug，究其根本，这些问题通常都源于并发编程中的“三座大山”：

> 

1.  **原子性 (Atomicity)** 

2.  **内存可见性 (Visibility)** 

3.  **有序性 (Ordering)** 

理解并妥善处理这三大特性，是写出正确、高效并发代码的关键。本文将深入探讨这三个概念，并结合Java中常用的工具，如 `synchronized` 、 `volatile` 和 `Lock` ，给出实用的解决方案。

---

## 一、原子性(Atomicity)：操作的“不可分割”性

**定义：** 原子性是指一个或多个操作在CPU执行过程中，要么全部执行成功，要么全部执行失败，不会被任何因素中断。就好比数据库事务的ACID特性中的原子性，它是一个“全有或全无”的概念。在多线程环境中，如果一个操作不具备原子性，当多个线程同时对共享变量进行操作时，就可能出现数据不一致的问题。

**举例：** `i++` 操作看似简单，实则包含三个步骤：

1. 读取 `i` 的值。

2. 将 `i` 的值加1。

3. 将新值写回 `i` 。

如果在多线程环境下，线程A读取了 `i` 的值，但在执行加1并写回之前，线程B也读取了 `i` 的旧值并完成了 `i++` 操作，那么线程A写回的将是基于旧值计算的结果，导致数据丢失，出现线程安全问题。

**Java中的解决方案：** 

-  **`synchronized` 关键字：** 
   `synchronized` 提供了互斥锁的功能，它可以修饰方法或代码块。当一个线程获取了对象的锁后，其他线程必须等待该线程释放锁才能继续执行。这确保了在同一时间只有一个线程执行被 `synchronized` 保护的代码，从而保证了代码块内操作的原子性。

  ```java
  public class AtomicExample {
      private int count = 0;

      public synchronized void increment() {
          count++; // count++ 变为原子操作
      }

      public int getCount() {
          return count;
      }
  }
  ```

-  **`Lock` 接口 (如 `ReentrantLock` )：** 
   `java.util.concurrent.locks.Lock` 提供了比 `synchronized` 更灵活的锁机制。它也通过获取和释放锁来保证操作的原子性。

  ```java
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReentrantLock;

  public class LockExample {
      private int count = 0;
      private final Lock lock = new ReentrantLock();

      public void increment() {
          lock.lock(); // 获取锁
          try {
              count++; // count++ 变为原子操作
          } finally {
              lock.unlock(); // 释放锁
          }
      }

      public int getCount() {
          return count;
      }
  }
  ```

-  **`java.util.concurrent.atomic` 包：** 
  该包下提供了 `AtomicInteger` 、 `AtomicLong` 等原子类，它们利用CAS（Compare-And-Swap）操作实现了无锁的原子性操作，性能通常优于加锁方式。

  ```java
  import java.util.concurrent.atomic.AtomicInteger;

  public class AtomicClassExample {
      private AtomicInteger count = new AtomicInteger(0);

      public void increment() {
          count.incrementAndGet(); // 原子性自增
      }

      public int getCount() {
          return count.get();
      }
  }
  ```

---

## 二、 内存可见性 (Visibility)：当一个线程修改了共享变量，另一个线程能立即看到吗？

**定义：** 可见性是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。在多核处理器架构下，每个CPU都有自己的高速缓存（Cache）。线程在执行时，通常会先将共享变量从主内存（RAM）复制到自己的CPU缓存中进行操作，操作完成后再写回主内存。这就可能导致一个线程对变量的修改，并不会立即同步到主内存，其他线程从自己的缓存中读取到的仍然是旧值。

**举例：** 

```java
public class VisibilityExample {
    private boolean flag = true;

    public void stop() {
        flag = false; // 线程A修改flag
    }

    public void run() {
        while (flag) { // 线程B读取flag
            // 执行任务
        }
        System.out.println("线程B停止了");
    }

    public static void main(String[] args) throws InterruptedException {
        VisibilityExample example = new VisibilityExample();
        new Thread(example::run).start(); // 启动线程B

        Thread.sleep(100); // 稍作等待
        new Thread(example::stop).start(); // 启动线程A修改flag
    }
}
```

在上述代码中，线程B可能永远不会停止，因为它可能一直从自己的缓存中读取 `flag` 的旧值 `true` ，而线程A修改的 `flag = false` 并没有及时同步到主内存或者线程B的缓存。

**Java中的解决方案：** 

-  **`volatile` 关键字：** 
   `volatile` 关键字保证了变量的可见性。当一个变量被 `volatile` 修饰时，对它的写操作会立即写入主内存，并且对它的读操作会从主内存中读取，而不是从线程的本地缓存中读取。```java
  public class VolatileVisibilityExample {
      private volatile boolean flag = true; // 添加volatile

      public void stop() {
          flag = false; // 线程A修改flag会立即同步到主内存
      }

      public void run() {
          while (flag) { // 线程B每次读取flag都会从主内存读取最新值
              // 执行任务
          }
          System.out.println("线程B停止了");
      }
  }
  ```

   **注意：** `volatile` 只能保证可见性，不保证原子性。例如， `volatile int i; i++` 依然不是原子操作。

-  **`synchronized` 关键字：** 
   `synchronized` 不仅保证了原子性，也隐式地保证了可见性。当一个线程释放 `synchronized` 锁时，它会把该锁保护的所有共享变量的最新值刷新到主内存中。当下一个线程获取该锁时，它会强制从主内存中读取这些共享变量的最新值。```java
  public class SynchronizedVisibilityExample {
      private boolean flag = true;

      public synchronized void stop() { // synchronized 保证可见性
          flag = false;
      }

      public synchronized boolean getFlag() { // synchronized 保证可见性
          return flag;
      }

      public void run() {
          while (getFlag()) { // 通过synchronized方法获取flag
              // 执行任务
          }
          System.out.println("线程B停止了");
      }
  }
  ```

-  **`Lock` 接口 (如 `ReentrantLock` )：** 
   `Lock` 接口也具备与 `synchronized` 类似的内存可见性保证。在 `lock.unlock()` 调用之后，会强制将修改写入主内存；在 `lock.lock()` 调用之前，会强制从主内存刷新读取。

---

## 三、 有序性 (Ordering)：代码执行顺序的“重排序”问题

**定义：** 有序性是指程序执行的顺序，在单线程环境下，程序的执行结果与代码的编写顺序一致。但在多线程环境下，为了提高性能，编译器和处理器可能会对指令进行重排序。这种重排序在不改变单线程程序执行结果的前提下，可能会打乱多线程环境下的执行逻辑，导致意想不到的问题。

**举例：** 
经典的“双重检查锁定”（Double-Checked Locking, DCL）单例模式中，如果不注意有序性，就可能出现问题。

```java
// 伪代码，存在有序性问题
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton(); // 1. 分配内存 2. 初始化对象 3. 设置instance指向内存
                }
            }
        }
        return instance;
    }
}
```

在 `instance = new Singleton()` 这一步，实际可能发生指令重排序：

1. 分配内存空间。

2. 设置 `instance` 变量指向刚分配的内存空间（此时 `instance` 不为 `null` ，但对象可能还未完全初始化）。

3. 初始化 `Singleton` 对象。

如果线程A执行到第2步， `instance` 已经不为 `null` ，但对象尚未完全初始化，此时线程B进入，判断 `instance != null` 成立，直接返回了未完全初始化的 `instance` ，导致程序出错。

**Java中的解决方案：** 

-  **`volatile` 关键字：** 
   `volatile` 不仅保证可见性，也通过插入内存屏障（Memory Barrier）来禁止指令重排序。对 `volatile` 变量的读写操作前后会插入特定的内存屏障，确保在屏障前后的指令不会乱序。```java
  // 解决DCL的有序性问题
  public class Singleton {
      private static volatile Singleton instance; // 添加volatile

      private Singleton() {}

      public static Singleton getInstance() {
          if (instance == null) {
              synchronized (Singleton.class) {
                  if (instance == null) {
                      instance = new Singleton(); // volatile 禁止了这里的重排序
                  }
              }
          }
          return instance;
      }
  }
  ```

-  **`synchronized` 关键字：** 
   `synchronized` 同样可以保证有序性。当进入 `synchronized` 块时，JVM会执行一个 `MonitorEnter` 指令，它相当于一个内存屏障，会清空工作内存并从主内存加载数据。当退出 `synchronized` 块时，JVM会执行一个 `MonitorExit` 指令，它也相当于一个内存屏障，会将工作内存中的修改刷新到主内存。这些内存屏障有效阻止了指令重排序。

-  **`Lock` 接口 (如 `ReentrantLock` )：** 
   `Lock` 接口的实现也提供了与 `synchronized` 类似的内存屏障效果，从而保证了有序性。

---

#### 总结与实践建议

并发编程中遇到的绝大多数问题，都可以归结为对原子性、可见性和有序性这“三座大山”的处理不当。

-  **原子性：** 确保共享变量的操作是不可分割的。使用 `synchronized` 、 `Lock` 或 `Atomic` 类来保证。

-  **可见性：** 确保一个线程对共享变量的修改能被其他线程及时看到。使用 `volatile` 、 `synchronized` 或 `Lock` 来保证。

-  **有序性：** 避免指令重排序带来的并发问题。 `volatile` 和 `synchronized` ( `Lock` ) 都能提供这种保证。

**实践建议：** 

1.  **优先考虑使用JUC（ `java.util.concurrent` ）包下的高级工具：** 它们通常经过高度优化，且使用更便捷，如 `ConcurrentHashMap` 、 `CountDownLatch` 、 `ThreadPoolExecutor` 等。

2.  **谨慎使用 `volatile` ：** `volatile` 适用于只涉及单个变量读写的简单场景，且不要求原子性的情况。如果涉及复合操作或需要原子性，仍需结合 `synchronized` 或 `Lock` 。

3.  **理解 `synchronized` 和 `Lock` 的异同：** `synchronized` 是JVM层面的，使用简单但不够灵活； `Lock` 是API层面的，提供了更丰富的特性（如可中断、公平锁、读写锁）。根据具体需求选择。

4.  **尽量减少共享变量：** 减少共享变量是避免并发问题的最直接方法。考虑使用线程本地变量（ `ThreadLocal` ）或不可变对象。

5.  **编写可测试的并发代码：** 使用单元测试和并发测试框架来验证并发逻辑的正确性，因为并发问题往往难以复现。

