# 【集合篇03】：源码剖析HashMap实现原理

> 原创 已于 2025-07-06 11:04:54 修改 · 公开 · 978 阅读 · 8 · 24 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149144845

**文章目录**

[TOC]



## 一、 核心数据结构：不只是数组+链表

从宏观上看， `HashMap` 的底层数据结构是 **哈希表（Hash Table）** 在 JDK 1.8 中，它的具体实现是 **“数组 + 链表 / 红黑树”** 

当我们查看 `HashMap` 的源码时，可以看到几个关键的成员变量：

```java
// 默认初始容量 (必须是2的幂)
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16

// 数组，也叫哈希桶 (table)
transient Node<K,V>[] table;

// Map中存储的键值对数量
transient int size;

// 扩容阈值，当 size > threshold 时，会触发 resize
int threshold;

// 负载因子，决定了哈希桶的填充程度
final float loadFactor; // 默认为 0.75f
```

-  **`table`** : 这就是我们常说的“数组”部分，它的每一个位置被称为一个“桶（bucket）”或“槽（slot）”

-  **`size`** : `HashMap` 中实际存储的键值对（ `Node` ）的数量

-  **`loadFactor` (负载因子)** : 默认为 **0.75** 它表示数组的填充比例，当 `size` 超过 `capacity * loadFactor` 时，就会触发扩容

-  **`threshold` (扩容阈值)** : 其值为 `capacity * loadFactor` 

---

## 二、 `put(key, value)` 方法

`put` 方法是 `HashMap` 的核心当我们调用 `map.put("name", "zhangsan")` 时，内部发生了什么？

### 1. 计算哈希值 (hash)

`HashMap` 并不会直接使用 `key` 的 `hashCode()` 方法返回值为了减少哈希冲突，它会对 `key.hashCode()` 进行二次处理

```java
static final int hash(Object key) {
    int h;
    // 如果 key 为 null，哈希值为 0
    // 否则，将 key 的 hashCode 值与其高16位进行异或运算
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

**细节追问：为什么要做 `(h >>> 16)` 异或操作？** 
这是为了让哈希值的高位也能参与到后续的索引计算中，从而让哈希分布更均匀，减少冲突。因为后续的索引计算 `(n - 1) & hash` 只使用了哈希值的低位，如果不做这个扰动函数，高位的差异将完全丢失

### 2. 计算数组下标 (index)

得到哈希值后，需要确定这个键值对要存放在 `table` 数组的哪个位置 `HashMap` 使用了非常高效的位运算

`int index = (n - 1) & hash;` 

其中 `n` 是数组 `table` 的长度（capacity）

**细节追问：为什么用 `&` 运算而不是 `%` 取余？** 
当 `n` 是 **2的幂** 时， `(n - 1) & hash` 的结果等价于 `hash % n` 但位运算 `&` 的效率远高于取余运算 `%` 这也是 `HashMap` 的容量总是2的幂次方的原因之一

> 关于该等式的证明可以参考： **[a % b == a & (b - 1)](https://blog.csdn.net/lyh2004_08/article/details/149150274)** 

### 3. 存放键值对

计算出 `index` 后，就找到了对应的桶，此时，会遇到以下几种情况：

-  **情况一：桶为空 ( `table[index] == null` )** 
  直接创建一个新的 `Node` 节点（包含 key, value, hash, next 指针）放入该桶中即可

-  **情况二：桶不为空（发生哈希冲突）** 

  1.  **Key 相同，覆盖值** ：检查桶中第一个节点的 `key` 是否与当前要存入的 `key` 相同（通过 `hash` 值和 `equals()` 方法判断）如果相同，则直接用新的 `value` 覆盖旧的 `value` ，并返回旧值

  2.  **Key 不同，链式追加或树化** ：

     -  **如果当前桶是链表结构** ：遍历这个链表，如果中途发现有 `key` 相同的节点，则覆盖其 `value` ；如果遍历到链表末尾仍未发现相同 `key` ，则将新节点以 **尾插法** 的形式追加到链表末尾

     -  **如果当前桶是红黑树结构** ：调用红黑树的插入方法 ( `putTreeVal` ) 将新节点添加到树中

### 4. 检查是否需要树化 (Treeify)

在向链表追加新节点后， `HashMap` 会检查该链表的长度

- 如果链表长度 **大于等于** `TREEIFY_THRESHOLD` (默认为 **8** )，并且数组 `table` 的长度 **大于等于** `MIN_TREEIFY_CAPACITY` (默认为 **64** )， `HashMap` 会将这条链表转化为红黑树，以将查询时间复杂度从 O(n) 优化到 O(log n)

### 5. 检查是否需要扩容 (Resize)

每次成功添加一个新节点后， `size` 会加 1此时会检查 `size` 是否超过了扩容阈值 `threshold` 如果超过，则会触发 `resize()` 方法

> 参考： **[resize() 方法的源码详细解读](https://blog.csdn.net/lyh2004_08/article/details/149148936)** 

---

## 三、JDK 1.7 与 1.8 的 `HashMap` 有何区别？

我们可以从以下几个关键点进行对比：

| 特性 | JDK 1.7 | JDK 1.8 |
|:---|:---|:---|
|  **数据结构**  |  **数组 + 链表**  |  **数组 + 链表 / 红黑树**  |
|  **冲突处理**  | 始终使用链表（拉链法）来解决哈希冲突 | 当链表长度 > 8 且数组长度 >= 64 时，链表会转化为红黑树 |
|  **插入方式**  |  **头插法** ：新元素插入链表头部在多线程环境下，扩容时可能导致链表形成环，造成死循环 |  **尾插法** ：新元素插入链表尾部修复了 1.7 中的死循环问题，但 `HashMap` 本身仍是线程不安全的 |
|  **哈希计算**  | 哈希函数相对复杂，进行了多次扰动计算 | 简化为一次异或运算 `(h = key.hashCode()) ^ (h >>> 16)` ，效率更高 |
|  **扩容逻辑**  | 需要对每个元素重新计算哈希值和在新数组中的位置 |  **优化了扩容** ：元素在新数组中的位置要么在 **原索引** ，要么在 **原索引 + 旧容量** 的位置，通过 `(e.hash & oldCap) == 0` 判断，无需重新计算哈希，效率更高 |


---

## 四、总结

1.  **数据结构** ：先说整体是哈希表，再细化为 JDK 1.8 的“数组 + 链表 / 红黑树”

2.  **`put` 流程** ：详细描述 `hash()` 计算 -> `index` 计算 -> 分情况（桶为空/不为空）处理 -> 检查树化 -> 检查扩容能说出 `hash` 和 `index` 的计算细节是加分项

3.  **1.7 vs 1.8** ：清晰地列出数据结构、插入方式、扩容逻辑等核心区别特别是扩容时的优化，是考察深度的关键

4.  **红黑树** ：解释其作用——在哈希冲突严重时，将时间复杂度从 O(n) 优化到 O(log n)，提升性能，防止哈希攻击

