# 【多线程篇25】：如何确定线程池核心线程数

> 原创 于 2025-07-24 08:00:00 发布 · 公开 · 1.6k 阅读 · 36 · 31 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149579541

**文章目录**

[TOC]



## 一、 核心概念：任务类型的划分

在讨论具体公式之前，我们必须先理解两种最基本的任务类型，这是所有配置策略的基石：

-  **计算密集型 (CPU-bound) 任务：** 

  -  **特点：** 这类任务需要进行大量的CPU计算，例如复杂的算法、数据加密/解密、图形渲染、大规模数据处理等。CPU会长时间处于“满载”状态，几乎没有等待时间

  -  **目标：** 最大化CPU利用率，同时减少不必要的线程上下文切换开销

-  **IO密集型 (I/O-bound) 任务：** 

  -  **特点：** 这类任务大部分时间都在等待I/O操作完成，例如读写数据库、调用外部API、读写文件、网络请求等。在等待期间，CPU是空闲的，可以去处理其他任务

  -  **目标：** 在一个线程等待I/O时，让其他线程能够利用空闲的CPU，从而提高整体吞吐量

---

## 二、 场景化分析：不同情况下的配置策略

### 场景一：高并发、任务执行时间短

>  **参考：** ① 高并发、任务执行时间短 → (CPU核数 + 1) ，减少线程上下文的切换

这种场景通常对应的是 **计算密集型任务** 。任务本身耗时极短，但请求量巨大

-  **公式：** `核心线程数 = CPU核数 + 1` 

-  **原理解析：** 

  - 对于计算密集型任务，理论上 `线程数 = CPU核数` 时，可以达到最高的CPU利用率，因为每个核心都恰好有一个线程在执行

  - 为什么是 `+1` 呢？这个额外的线程是为了防止某个线程因偶尔的页错误（Page Fault）或其他原因而阻塞时，CPU能够立刻有另一个线程顶上，不至于空闲

  - 设置过多的线程没有意义，因为CPU核心数是固定的，多出来的线程只会争抢CPU资源，频繁进行上下文切换，反而会增加系统开销，降低性能

### 场景二：并发不高、任务执行时间长

>  **参考：** ② 并发不高、任务执行时间长 → 分为IO密集型和计算密集型

这种情况需要根据任务的具体性质来细分

-  **如果是计算密集型任务：** 

  -  **公式：** `核心线程数 = CPU核数 + 1` 

  -  **解析：** 即使并发不高，但只要是纯计算任务，最大化CPU利用率的原则依然不变

-  **如果是IO密集型任务：** 

  -  **公式：** `核心线程数 = CPU核数 * 2 + 1` (这是一个常见的经验值)

  -  **原理解析：** IO密集型任务的大部分时间都在等待。假设我们设置的线程数等于CPU核数，那么当所有线程都在等待I/O时，CPU就完全空闲了，造成资源浪费。因此，我们需要配置更多的线程。当一部分线程在等待时，另一部分线程可以继续使用CPU

  -  `* 2` 是一个经验性的系数，意味着我们假设线程的等待时间和计算时间大致相等。 `+1` 同样是为了备份

  -  **更精确的公式（进阶）：** 业界有一个更经典的公式，由《Java Concurrency in Practice》提出：
     `核心线程数 = CPU核数 * (1 + 线程平均等待时间 / 线程平均计算时间)` 
    这个公式可以更精确地反映IO密集程度。例如，如果等待时间是计算时间的3倍，那么线程数就可以设置为 `CPU核数 * (1 + 3) = CPU核数 * 4` 

### 场景三：高并发、业务执行时间长

>  **参考：** ③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考 (2)

这是最复杂，也是最接近真实世界高负载业务的场景。图片中的建议非常深刻： **当瓶颈出现时，首先要考虑的是优化业务逻辑和架构，而不是盲目地调整线程池参数。** 

-  **为什么不能简单增加线程数？** 

  - 一个耗时很长的任务，在高并发下，如果无限制地增加线程，会迅速耗尽服务器的内存和CPU资源。每个线程都需要占用一定的内存空间，过多的线程会导致激烈的CPU竞争和频繁的上下文切换，系统性能将急剧下降，甚至OOM（Out of Memory）

-  **正确的解决思路：** 

  1.  **架构和业务优化（治本）：** 

     -  **缓存：** 能否用Redis等缓存来减少对数据库的直接访问？这是最常见的优化手段

     -  **异步化/解耦：** 能否将一个长任务拆分成多个小任务，通过消息队列（如RabbitMQ, Kafka）进行异步处理？例如，用户下单后，后续的库存扣减、积分发放、短信通知等都可以异步执行，快速响应用户

     -  **算法优化：** 任务内部是否存在可以优化的慢查询或复杂算法？

  2.  **资源扩展（治标）：** 

     -  **水平扩展：** 增加服务器实例，通过负载均衡将请求分发出去

  3.  **最后的线程池设置：** 

     - 在完成了上述优化，将“长任务”变成了“短任务”之后，再回过头来，根据优化后任务的类型（是计算密集型还是IO密集型），参考 **场景二** 中的公式来设置线程池

---

## 三、 实践中的黄金法则

1.  **先分析，再配置：** 不要凭感觉设置，先用工具（如Arthas, JProfiler, VisualVM）分析任务的CPU和I/O耗时，确定任务类型

2.  **公式是起点，不是终点：** 上述公式为我们提供了科学的初始值。但最佳值一定是通过 **压力测试** 不断调整和验证得出的。在预生产环境模拟真实流量，观察系统的CPU利用率、内存使用、响应时间和吞吐量，找到那个“最佳平衡点”

3.  **别忘了其他参数：** 一个线程池的性能不仅取决于 `corePoolSize` ，还与 `maximumPoolSize` （最大线程数）、 `workQueue` （工作队列）、 `keepAliveTime` （线程存活时间）和 `RejectedExecutionHandler` （拒绝策略）息息相关，需要综合考虑

4.  **动态获取CPU核数：** 在代码中，应该动态获取CPU核数，而不是硬编码，以保证代码在不同环境下的可移植性

   ```java
   // 使用 cpuCores 来计算你的线程数
   int cpuCores = Runtime.getRuntime().availableProcessors();
   ```

