# 【多线程篇09】：一文看懂CAS技术与乐观锁思想

> 原创 于 2025-07-14 08:15:00 发布 · 公开 · 848 阅读 · 18 · 9 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149307798

**文章目录**

[TOC]


在并发编程中，我们最熟悉的线程同步工具是 `synchronized` 和 `ReentrantLock` 。它们遵循一种 **悲观** 的策略：无论是否真的会发生冲突，都先加锁，确保同一时刻只有一个线程能访问临界区。这种方式虽然安全，但在低并发或无并发的场景下，加锁、解锁以及线程上下文切换的开销会成为性能瓶颈

有没有一种更 **乐观** 的方式呢？答案是肯定的。这就是我们今天要深入探讨的核心技术—— **CAS (Compare-And-Swap)** 

## 1. 什么是 CAS？

CAS，全称 Compare-And-Swap（比较并交换），是一种硬件层面支持的原子操作。它并非 Java 独有，而是现代处理器提供的一条特殊指令，用于实现多线程环境下的无锁化（Lock-Free）操作

CAS 操作包含三个核心操作数：

1.  **V (Variable)** ：需要读写的内存位置（即共享变量）

2.  **A (Assumed/Expected)** ：预期的旧值

3.  **B (New Value)** ：准备要写入的新值

**其执行逻辑是：** 当且仅当内存位置 **V** 的当前值等于预期旧值 **A** 时，处理器才会原子地将该位置的值更新为新值 **B** 。如果 V 的值不等于 A，那么处理器什么也不做，操作失败。无论成功与否，这个操作都会返回 V 的旧值

**通俗地讲，CAS 的逻辑就是这样：** 

> 我认为内存地址 V 的值现在应该是 A，如果是，那你就把它改成 B；如果不是，那你别动，告诉我它现在到底是多少

最关键的一点是， **“比较”和“交换”这两个动作是一个不可分割的 <u>原子</u> 操作** ，由 CPU 硬件保证，期间不会被任何其他线程中断

---

## 2. CAS 的工作原理：乐观锁的实现

CAS 体现了一种 **乐观锁** 的思想。它总是乐观地认为自己操作共享数据时不会有其他线程来干扰，所以它不会加锁。它只是在更新数据前，检查一下数据是否被别人修改过

这种思想在实际应用中通常通过 **自旋（Spinning）** 的方式实现：

1. 从内存中读取共享变量的当前值（我们称之为 `currentValue` ）

2. 基于 `currentValue` 计算出新值（我们称之为 `newValue` ）

3. 使用 CAS 尝试将内存中的值从 `currentValue` 更新为 `newValue` 

4. 如果 CAS 操作成功，说明在步骤 1 到 3 之间没有其他线程修改过这个变量，任务完成

5. 如果 CAS 操作失败，说明在步骤 1 到 3 之间，有其他线程已经修改了该变量。此时，当前线程不会被挂起，而是会 **重新执行第一步** ，获取最新的值，然后再次尝试 CAS 操作，直到成功为止

这种不断重试的过程，就叫做**“自旋”**

---

## 3. Java 中的 CAS： `Unsafe` 类与原子类

在 Java 中，我们通常不直接使用底层的 CAS 指令，而是通过 JUC (java.util.concurrent) 包提供的封装好的 API 来使用

-  **`sun.misc.Unsafe` 类** ：这是 Java 中一个能够执行类似 C++ 指针操作的“后门”类。它提供了如 `compareAndSwapInt()` , `compareAndSwapLong()` 等直接调用 CAS 指令的方法。但由于其不安全性，官方不推荐开发者直接使用

-  **原子类 ( `java.util.concurrent.atomic` 包)** ：这是 Java 官方为我们提供的、基于 CAS 实现的线程安全的工具类，如 `AtomicInteger` , `AtomicLong` , `AtomicReference` 等。 **它们是使用 CAS 的标准和安全方式** 

让我们以 `AtomicInteger` 的 `getAndIncrement()` 方法（原子地加一）为例，看看其（简化后的）内部实现：

```java
public final int getAndIncrement() {
    // 使用 Unsafe 类的 CAS 方法
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

// Unsafe.getAndAddInt 的内部逻辑
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        // 1. 读取当前内存中的值
        v = getIntVolatile(o, offset);
        // 2. 尝试用 CAS 将当前值 v 更新为 v + delta
    } while (!compareAndSwapInt(o, offset, v, v + delta)); // 3. 如果失败，则循环重试
    return v;
}
```

可以看到，这完美地体现了“CAS + 自旋”的实现模式

---

## 4. CAS 的三大挑战

CAS 虽然高效，但也存在一些著名的问题

### 1. ABA 问题

这是 CAS 最经典的问题。如果一个变量 V 的值，在某个时间点从 A 变成了 B，然后又变回了 A。当一个线程使用 CAS 进行操作时，它会检查发现 V 的值仍然是 A，于是操作成功。但实际上，这个变量的状态已经发生过变化

>  **生活中的例子：** 
> 
> 你有 100 元，想取 50 元。你看到余额是 100（预期值 A），准备操作。
> 
> 这时，你家人给你转了 50 元（余额变 150），然后又用这 50 元买了东西（余额变回 100）。
> 
> 你回头执行取款操作，CAS 检查发现余额还是 100，操作成功。
> 
> 虽然最终余额是对的， **但中间的状态变化被忽略了** ，这在某些需要追踪过程的业务场景中是致命的

**解决方案：版本号机制** 。Java 提供了 `AtomicStampedReference` 类，它在更新变量值的同时，还会更新一个“时间戳”（或版本号）。CAS 操作时不仅要比较值，还要比较版本号，只有两者都相同时才能操作成功，从而解决了 ABA 问题

### 2. 循环时间长开销大

如果并发冲突非常激烈，会导致大量线程反复自旋，长时间地尝试 CAS 操作却不成功。这会 **持续消耗 CPU 资源** ，给系统带来很大压力。在这种高并发场景下，CAS 的性能可能还不如让线程阻塞的重量级锁

**结论** ：CAS 适用于 **低到中度并发** 的场景，在高并发场景下，需要权衡其与锁的开销

### 3. 只能保证单个共享变量的原子操作

CAS 操作一次只能保证一个共享变量的原子性。如果你需要同时对多个变量进行原子更新（例如，原子地将 a 加 1，b 减 1），CAS 本身是无能为力的

**解决方案：** 

1. 使用传统的 `synchronized` 或 `ReentrantLock` 来锁定这段代码

2. 将多个变量封装成一个对象，然后使用 `AtomicReference` 来对这个对象的引用进行原子操作

---

## 总结

CAS 是一种强大而高效的并发控制技术，它是许多高性能并发框架和类的基石

-  **优点** ：在低并发环境下，通过避免线程阻塞和上下文切换，提供了比传统锁更高的性能

-  **缺点** ：存在 ABA 问题、高并发下自旋开销大、只能保证单个变量的原子性等挑战

