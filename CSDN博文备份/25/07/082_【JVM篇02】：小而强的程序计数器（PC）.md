# 【JVM篇02】：小而强的程序计数器（PC）

> 原创 于 2025-07-25 08:15:00 发布 · 公开 · 835 阅读 · 18 · 16 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149594988

**文章目录**

[TOC]



## 一、什么是程序计数器？

**官方定义** ：程序计数器是一块较小的内存空间，它可以看作是 **当前线程所执行的字节码的行号指示器** 

**通俗理解** ：如果把执行引擎比作一个正在阅读代码的“人”，那么程序计数器就是他手指着的、正要阅读的那一行代码的“行号”。它告诉执行引擎，下一条应该执行哪条字节码指令

在任何时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。为了在多线程环境下能够正确地切换和恢复线程的执行状态，每个线程都必须有一个独立的程序计数器。当线程被切换回来时，它需要知道从哪里继续执行

---

## 二、程序计数器的核心特点

1.  **线程私有（Thread-Private）** 
   这是程序计数器最重要的特性。JVM支持多线程并发执行，CPU会在不同线程之间进行快速切换。为了让每个线程在被切走后，下次还能准确地回到上次执行的位置，JVM为 **每一条线程** 都分配了一个独立的程序计数器。各个线程的程序计数器互不影响，独立存储

2.  **存储内容** 

   - 如果线程正在执行的是一个 **Java 方法** ，这个计数器记录的是正在执行的虚拟机 **字节码指令的地址** （或偏移量）

   - 如果正在执行的是 **Native 方法** （本地方法，由C/C++等语言实现），这个计数器的值则为 **空（Undefined）** 。因为Native方法的执行不归JVM管理，而是由操作系统直接调度，所以JVM的程序计数器无法追踪其执行位置

3.  **无内存溢出（OutOfMemoryError）** 
   程序计数器是《Java虚拟机规范》中 **唯一一个没有规定任何 `OutOfMemoryError` 情况的区域** 。它所占用的内存空间非常小，在线程创建时分配，大小固定，不会因为程序运行而改变，因此也就不存在内存溢出的问题

---

## 三、代码佐证：如何“看到”程序计数器？

我们无法在Java代码中直接访问或操作程序计数器，但可以通过反编译字节码来直观地理解它的工作原理。我们将使用JDK自带的 `javap` 工具

**1. 示例代码** 

创建一个简单的Java类 `PCRTest.java` ：

```java
public class PCRTest {
    public int calculate() {
        int a = 1;
        int b = 2;
        int result = (a + b) * 10;
        return result;
    }
}
```

**2. 编译与反编译** 

在命令行中执行以下命令：

```bash
# 1. 编译Java源文件为字节码文件
javac PCRTest.java

# 2. 使用javap反编译，查看字节码指令
# -c 参数表示反编译代码
javap -c PCRTest.class
```

**3. 分析输出结果** 

得到下面的输出：

```java
Compiled from "PCRTest.java"
public class PCRTest {
  public PCRTest();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public int calculate();
    Code:
       0: iconst_1      // 将int型常量1压入操作数栈
       1: istore_1      // 将栈顶的1存入局部变量表索引为1的位置 (变量a)
       2: iconst_2      // 将int型常量2压入操作数栈
       3: istore_2      // 将栈顶的2存入局部变量表索引为2的位置 (变量b)
       4: iload_1       // 从局部变量表加载变量a到操作数栈
       5: iload_2       // 从局部变量表加载变量b到操作数栈
       6: iadd          // 执行加法，结果留在栈顶
       7: bipush   10   // 将int型常量10压入操作数栈
       9: imul          // 执行乘法，结果留在栈顶
      10: istore_3      // 将结果存入局部变量表索引为3的位置 (变量result)
      11: iload_3       // 加载result到操作数栈
      12: ireturn       // 返回栈顶的int值
}
```

**结果解读** ：

-  `Code:` 下方的每一行都是一条字节码指令

-  **最左侧的数字（0, 1, 2, 3, 4, …）** 就是字节码指令的 **地址（或称为偏移量）** 

-  **程序计数器存储的就是这些地址值** 

当 `calculate` 方法开始执行时：

1. 程序计数器的值为 `0` 。执行引擎取出 `iconst_1` 指令执行

2. 执行完毕后，程序计数器更新为下一条指令的地址 `1` 

3. 执行引擎根据值为 `1` 的程序计数器，取出 `istore_1` 指令执行

4. …以此类推，直到 `ireturn` 指令执行完毕，方法结束

这个过程清晰地展示了程序计数器是如何像一个“指示器”一样，驱动着执行引擎一步步地执行代码的

---

## 四、面试总结

当面试官问到“什么是程序计数器”时，你可以这样回答：

1.  **是什么** ：程序计数器是JVM运行时数据区的一部分，它是一个线程私有的内存区域，作用是记录当前线程正在执行的字节码指令的地址

2.  **为什么需要** ：

   - 因为 **JVM是多线程的** ， **CPU会进行线程切换** 

   - 程序计数器保证了每个线程在被切换回来后，能从正确的位置继续执行，它是实现多线程并发正确性的基础

3.  **有什么特点** ：

   -  **线程私有** ：每个线程都有一个

   - 执行Java方法时，它存储字节码地址；执行Native方法时，它为空（Undefined）

   - 它是JVM内存区域中 **唯一不会发生 `OutOfMemoryError`** 的部分

