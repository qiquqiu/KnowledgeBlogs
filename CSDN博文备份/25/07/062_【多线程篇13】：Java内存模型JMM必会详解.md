# 【多线程篇13】：Java内存模型JMM必会详解

> 原创 于 2025-07-18 00:31:14 发布 · 公开 · 1.2k 阅读 · 27 · 21 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149433419

**文章目录**

[TOC]



## 1.JMM是什么？

Java内存模型（Java Memory Model, JMM）是一个 **抽象的概念和规范** 。它并非真实存在的物理内存划分，而是Java虚拟机（JVM）定义的一套规则，用来 **屏蔽各种硬件和操作系统的内存访问差异** ，以实现让Java程序在各种平台下都能达到一致的内存访问效果

简单来说，JMM定义了 **线程和主内存之间的抽象关系** 以及 **线程之间共享变量的可见性、有序性和原子性** 的规则

---

## 2. 为什么需要JMM？

JMM的出现主要为了解决两个核心问题：

1.  **平台一致性问题** ：

   - 不同的CPU架构有不同的内存模型，例如，一些CPU的缓存一致性协议较强，而另一些则较弱。

   - 如果不定义一个统一的规范，那么一套并发代码在x86处理器上运行正常，但在ARM处理器上可能就会出现问题

   - JMM通过建立一个统一的内存模型，保证了Java的“一次编写，到处运行”（Write Once, Run Anywhere）的承诺在并发编程领域依然有效

2.  **由硬件优化引发的并发问题** ：

   - 现代计算机为了提升性能，在硬件层面做了很多优化，主要包括：

     -  **CPU高速缓存（Caches）** ：CPU的运行速度远快于主内存。为了弥补这个速度鸿沟，CPU引入了多级高速缓存。这导致每个CPU核心都可能缓存共享变量的副本，从而引发 **可见性** 问题（一个线程修改了变量，另一个线程看不到最新的值）

     -  **指令重排序（Instruction Reordering）** ：为了优化执行效率，处理器和编译器可能会对输入的代码指令进行乱序执行（只要保证单线程内的最终结果一致）。但在多线程环境下，这种重排序可能打破程序原有的逻辑，导致 **有序性** 问题

JMM的职责就是定义一套规则，让开发者在遵循这些规则的前提下，能够编写出正确、可预测的并发程序，而无需关心底层复杂的硬件细节。开发者使用的 `volatile` 、 `synchronized` 、 `final` 和 `java.util.concurrent` 包下的工具类，其底层实现都严格遵守JMM规范

---

## 3. JMM的核心抽象：主内存与工作内存

为了规范线程间的交互，JMM抽象出了两个概念：

-  **主内存（Main Memory）** ：

  - 这是一个所有线程 **共享** 的区域

  - 所有共享变量（实例字段、静态字段、构成数组对象的元素）都存储在主内存中

  -  **注意** ：这里的“主内存”与JVM内存区域中的“Java堆”或“方法区”在概念上有所关联但并不等同。可以理解为，堆和方法区中存储的共享数据，逻辑上都属于JMM的主内存范畴

-  **工作/本地内存（Working Memory）** ：

  - 这是每个线程 **私有** 的区域

  - 线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行， **不能直接读写主内存中的变量** 

  - 工作内存中存储的是主内存中共享变量的 **副本** 

  -  **重要细节** ：工作内存是一个 **抽象概念** ，它涵盖了CPU高速缓存、寄存器、写缓冲区等，并非一块真实的内存区域

**线程间通信过程** ：
线程A和线程B如果要通信（例如A修改一个共享变量，B来读取），必须通过主内存作为中介

1.  **线程A** 将更新后的共享变量值从自己的工作内存 **刷新（flush）** 到主内存

2.  **线程B** 从主内存中 **读取（read）** 该共享变量的最新值到自己的工作内存

这个模型清晰地揭示了 **可见性问题** 的根源：如果线程A修改了变量但没有及时刷新到主内存，或者线程B没有及时从主内存更新，那么B看到的就是旧值

---

## 4. JMM的内存间交互操作

有这8种原子操作：

>  `lock` , `unlock` , `read` , `load` , `use` , `assign` , `store` , `write` （了解即可）

共同定义了变量如何从主内存拷贝到工作内存、以及如何从工作内存同步回主内存的 **底层实现细节和规则** 。
它们确保了 `volatile` 等关键字能够实现其承诺的内存可见性效果。
例如，对一个 `volatile` 变量的写操作，会强制触发 `store` 和 `write` 操作，立即将新值同步到主内存；对 `volatile` 变量的读操作，会强制触发 `read` 和 `load` 操作，从主内存获取最新值

---

## 5. JMM与JVM内存区域的区别（面试高频点）

这是一个非常关键的区别点，必须清晰地阐述。

| 特性 | Java内存模型 (JMM) | JVM内存区域 (Runtime Data Areas) |
|:---|:---|:---|
|  **层面/范畴**  |  **并发编程规范** ，是语言层面的 **抽象模型**  |  **JVM运行时内存布局** ，是JVM管理的 **物理或逻辑分区**  |
|  **目的**  | 解决多线程环境下的 **可见性、有序性、原子性** 问题，屏蔽底层硬件差异 | 定义程序在运行时，数据 **存储在哪里** 的问题 |
|  **核心概念**  |  **主内存** 、 **工作内存** 、 `happens-before` 原则、重排序、内存屏障 |  **堆(Heap)** 、 **虚拟机栈(VM Stack)** 、 **方法区(Method Area)** 、程序计数器、本地方法栈 |
|  **关系**  | JMM决定了 **如何** 在这些内存区域中安全地读写共享变量 | JVM内存区域是JMM所依赖的 **数据载体** 。例如，JMM中的主内存主要对应JVM内存区域的堆和方法区 |


**一个精准的比喻** ：

-  **JVM内存区域** 就像是要盖房子的 **地皮划分** ：这里是客厅（堆），那里是卧室（栈），那里是书房（方法区）。它规定了什么东西（对象、方法调用）应该放在哪里

-  **JMM** 就像是这栋房子里的 **行为规范和安保系统** ：规定了家庭成员（线程）之间如何安全地传递物品（共享变量），如何保证一个人放下的东西能被另一个人看到（可见性），以及做事的先后顺序不能乱（有序性）

---

## 总结

1.  **定义** ：JMM是一套并发编程的规范，为了解决硬件优化（缓存、重排序）和平台差异带来的问题

2.  **核心模型** ：通过抽象的“主内存”和“工作内存”概念来描述线程间的交互，点出这是“可见性”问题的根源

3.  **目的** ：JMM通过定义规则（如 `happens-before` 原则，虽然你没提供但这块是JMM核心），并由 `volatile` 、 `synchronized` 等关键字具体实现，来保证并发编程的 **可见性** 和 **有序性** 

4.  **关键区别** ：能清晰地、有条理地区分JMM和JVM内存区域，说明前者是行为规范，后者是存储划分

