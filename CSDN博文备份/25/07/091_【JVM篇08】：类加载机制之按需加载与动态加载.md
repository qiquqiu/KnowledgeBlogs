# 【JVM篇08】：类加载机制之按需加载与动态加载

> 原创 于 2025-07-28 07:45:00 发布 · 公开 · 945 阅读 · 13 · 23 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149698070

**文章目录**

[TOC]


上篇文章我们初步了解了类加载器的三层结构（Bootstrap、Extension、Application ClassLoader）和双亲委派模型，以及一个简单demo的详细加载流程。本篇，我们将深入探讨 Java 类加载机制的核心原则： **“按需加载”** 

## 1. 什么是“按需加载”？

这个描述了Java 类加载器的一些重要行为特征：

-  **按需加载** ：顾名思义，就是“用到才加载”。这意味着一个类并不会在 JVM 启动时一股脑地全部加载到内存中，而是只有在它第一次被 JVM 引用和需要使用时，才会被加载到内存中（ **惰性加载** ）

-  **动态加载** ：这是“按需加载”的实现方式。JVM 会在运行时，根据程序的执行流程， **动态地查找、加载** 所需的类

这两个原则的存在，使得 Java 应用能够更高效地利用内存和启动资源

---

## 2. 类加载器回顾：三层结构与双亲委派模型

在理解“按需加载”之前，我们快速回顾一下 Java 的类加载器体系：

1.  **Bootstrap ClassLoader (启动类加载器)** ：

   - C++ 实现，JVM 最顶层

   - 加载 JVM 运行所需 **最核心** 的 Java 类库（如 `java.lang.*` , `java.util.*` 等），这些类通常位于 JDK 的 `lib/modules` 等内部模块路径中（在 JDK 9+ 中）

2.  **Extension ClassLoader (扩展类加载器)** ：

   - Java 实现，是 Bootstrap ClassLoader 的子级

   - 在 JDK 9+ 中作用削弱，主要用于兼容遗留的扩展 JAR 包

3.  **Application ClassLoader (应用程序类加载器)** ：

   - Java 实现，是 Extension ClassLoader 的子级

   - 加载应用程序自身的类（我们写的代码）和第三方库（如 Maven/Gradle 依赖的 JAR 包），从 `classpath` 指定的路径加载

而 **双亲委派模型** 则规定了类加载的委派顺序：

当一个类加载器收到加载请求时，它会首先将请求 **委派给它的父类加载器** ，只有当父类加载器无法加载时，它才会尝试自己去加载。这个模型是实现“按需加载”和保障类库安全的关键

---

## 3. “按需加载”在实际流程中的体现

让我们通过一个具体的例子，来展示 **“按需加载”** 和 **“动态加载”** 如何在类加载器的工作流程中发挥作用

假设我们有一个 Java 程序 `MyApplication.java` ：

```java
package com.mycompany.app;

import java.util.Date; // 核心库类
import com.example.utils.Logger; // 第三方库类

public class MyApplication {
    public static void main(String[] args) {
        System.out.println("Application Starting..."); // 使用java.lang.System
        // 条件一：使用Date类
        if (args.length > 0 && args[0].equals("show_date")) {
            Date now = new Date();
            System.out.println("Current Date: " + now);
        }

        // 条件二：使用第三方Logger类
        if (args.length > 0 && args[0].equals("log_message")) {
            Logger.info("A message from the logger.");
        }

        System.out.println("Application Finished.");
    }
}
```

假设 `Logger.class` 存在于 `my-logger.jar` 中

### 场景一

> 仅运行 `java com.mycompany.app.MyApplication` (不带任何参数)

1.  **加载 `MyApplication` ：** Application ClassLoader 通过双亲委派模型，最终在 `classpath` 中加载 `com.mycompany.app.MyApplication` 

2.  **加载 `System` ：** 当 `main` 方法执行到 `System.out.println()` 时，会触发 `java.lang.System` 类的加载请求。这个请求会一直委派到 Bootstrap ClassLoader，它在 JDK 核心模块路径中找到并加载 `System.class` 

3.  **其他类呢？** 

   -  `java.util.Date` ：程序没有进入 `if (args[0].equals("show_date"))` 分支，因此 **不会** 创建 `Date` 对象， `Date` 类 **不会被加载** 

   -  `com.example.utils.Logger` ：程序没有进入 `if (args[0].equals("log_message"))` 分支，因此 **不会** 调用 `Logger.info()` ， `Logger` 类 **不会被加载** 

### 场景二

> 运行 `java com.mycompany.app.MyApplication show_date` 

1. 前两步同上， `MyApplication` 和 `System` 被加载

2. 程序进入 `if (args[0].equals("show_date"))` 分支

3. 当执行 `new Date()` 时，JVM 此时才发现需要 `java.util.Date` 类

4.  **动态加载 `Date` ：** `java.util.Date` 的加载请求从 Application ClassLoader 开始，向上委派到 Bootstrap ClassLoader。Bootstrap ClassLoader 在 JDK 核心模块路径中找到并加载 `Date.class` 

5.  `Logger` 类依然不会被加载，因为它仍未被使用

### 场景三

> 运行 `java com.mycompany.app.MyApplication log_message` 

1. 前两步同上， `MyApplication` 和 `System` 被加载

2. 程序进入 `if (args[0].equals("log_message"))` 分支

3. 当执行 `Logger.info()` 时，JVM 此时才发现需要 `com.example.utils.Logger` 类

4.  **动态加载 `Logger` ：** `Logger` 的加载请求从 Application ClassLoader 开始，向上委派到 Bootstrap ClassLoader。Bootstrap ClassLoader 找不到（非核心库），Extension ClassLoader 找不到（非扩展库）。请求退回到 Application ClassLoader。Application ClassLoader 在其 `classpath` 中找到 `my-logger.jar` 里的 `Logger.class` ，并加载它

5.  `Date` 类依然不会被加载

---

## 4. 总结“按需加载”与“动态加载”的重要性

通过上述例子，我们可以清晰地看到“按需加载”的价值：

-  **资源优化** ：JVM 仅加载程序当前执行路径所需的类， **避免了将所有可能用到的类（无论是核心库、第三方库还是应用程序自己的类）一次性全部加载到内存中** 。这显著减少了程序的内存占用

-  **启动速度提升** ：由于并非所有类都在启动时加载，程序的 **启动时间得以缩短** ，尤其对于大型应用或包含大量依赖的项目，这一点尤为重要

-  **灵活性** ：允许 JVM 在运行时根据需要加载和链接类，为插件机制、热部署等高级功能提供了基础

