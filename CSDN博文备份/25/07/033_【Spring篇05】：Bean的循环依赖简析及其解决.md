# 【Spring篇05】：Bean的循环依赖简析及其解决

> 原创 于 2025-07-02 10:40:35 发布 · 公开 · 873 阅读 · 18 · 24 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149064107

**文章目录**

[TOC]


在Spring框架中，循环依赖是一个常见但又复杂的问题。当两个或多个Bean相互依赖时，就会形成循环依赖。Spring通过三级缓存机制巧妙地解决了大部分循环依赖问题。本文将详细探讨Spring中的循环依赖问题及其解决方案。

---

## 什么是循环依赖？

循环依赖发生在两个或两个以上的Bean相互持有对方，形成一个闭环。例如，Bean A依赖于Bean B，而Bean B又依赖于Bean A，这就形成了一个循环依赖。

> 简单来说，循环依赖就是两个或多个 Bean 互相持有对方的引用，形成一个闭环。比如：
> 
> 

- Bean A 需要 Bean B。

- Bean B 也需要 Bean A。

这就像一个“鸡生蛋，蛋生鸡”的问题，在传统的对象创建流程中，如果没有特殊的处理机制，就会陷入无限循环，最终导致程序崩溃。

---

## Spring 解决循环依赖的“三级缓存”

Spring 框架非常聪明，它并没有对循环依赖采取“一刀切”的拒绝策略，而是允许它存在，并设计了一套行之有效的机制来解决大部分循环依赖问题。这个机制的核心就是著名的 **“三级缓存”** 。

我们可以把 Spring 容器创建 Bean 的过程想象成一个流水线，而这三级缓存就像流水线上的三个临时仓库：

1.  **一级缓存 ( `singletonObjects` )：单例池** 

   -  **作用：** 存放已经 **完全初始化** 并且可以投入使用的单例 Bean 对象。

   -  **类比：** 就像一个成品仓库，里面存放着已经组装好、经过质检、可以随时发货的产品。

2.  **二级缓存 ( `earlySingletonObjects` )：早期 Bean 缓存** 

   -  **作用：** 存放 **实例化完成，但尚未完成属性注入和初始化** 的早期 Bean 对象。

   -  **类比：** 就像一个半成品仓库，里面存放着已经有了基本框架，但还需要进一步加工和组装的产品。

3.  **三级缓存 ( `ObjectFactory` )：存放用于创建Bean的ObjectFactory** 

   -  **作用：** 存放创建 Bean 对象的 **ObjectFactory** 。ObjectFactory 是一个函数式接口，它的 `getObject()` 方法可以延迟创建 Bean 对象。

   -  **类比：** 就像一个生产指令仓库，里面存放着如何根据需求生产出特定半成品的指令。当需要一个半成品时，就从这个仓库里找到对应的指令，然后去生产。

**表格对比：** 

|  **缓存级别**  |  **名称**  |  **内容**  |  **类比**  |
|:---:|:---:|:---:|:---:|
|  **一级缓存**  | 单例池 (singletonObjects) | 存放已完全初始化的单例 Bean。 | 成品仓库：存放已经组装好、经过质检、可以随时发货的产品。 |
|  **二级缓存**  | 早期 Bean 缓存 (earlySingletonObjects) | 存放实例化完成但未完成属性注入和初始化的早期 Bean。 | 半成品仓库：存放已经有了基本框架，但还需要进一步加工和组装的产品。 |
|  **三级缓存**  | ObjectFactory 缓存 (singletonFactories) | 存放用于创建 Bean 的 ObjectFactory，可以延迟生成 Bean 的早期引用。 | 生产指令仓库：存放如何根据需求生产出特定半成品的指令。 |


---

## 解决流程举例

理解了三级缓存，我们再来看看 Spring 是如何利用它们来解决 Bean A 和 Bean B 之间的循环依赖：

1.  **实例化 A 对象，并创建 ObjectFactory 存入三级缓存。** 

   - 当 Spring 容器开始创建 Bean A 时，它首先会实例化 A 对象（分配内存空间）。

   - 接着，Spring 会创建一个 `ObjectFactory` ，这个 `ObjectFactory` 知道如何生成一个 Bean A 的早期引用。这个 `ObjectFactory` 被存入三级缓存。

   -  **此时：** 一级缓存、二级缓存都还没有 A。三级缓存有 A 的 ObjectFactory。

2.  **A 在初始化时需要 B 对象，开始 B 的创建逻辑。** 

   - 在 Bean A 的初始化过程中（例如，执行 `@Autowired` 注入属性），发现它需要 Bean B。

   - 于是，Spring 暂停 A 的初始化，转而开始创建 Bean B。

3.  **B 实例化完成，也创建 ObjectFactory 存入三级缓存。** 

   - 和创建 A 的过程类似，Spring 会实例化 Bean B，并创建一个 `ObjectFactory` 存入三级缓存。

   -  **此时：** 一级缓存没有。二级缓存没有。三级缓存有 A 的 ObjectFactory 和 B 的 ObjectFactory。

4.  **B 需要注入 A，通过三级缓存获取 ObjectFactory 生成 A 对象，存入二级缓存。** 

   - 在 Bean B 的初始化过程中，发现它需要 Bean A。

   - Spring 会首先去一级缓存查找 A，没找到。

   - 再去二级缓存查找 A，没找到。

   - 最后去三级缓存查找 A 的 `ObjectFactory` 。找到了！

   - Spring 通过这个 `ObjectFactory` 生成一个 Bean A 的早期引用（也就是实例化但未完成初始化的 A 对象），并将其存入二级缓存。

   -  **此时：** 一级缓存没有。二级缓存有早期 A。三级缓存有 A 和 B 的 ObjectFactory。

5.  **B 通过二级缓存获得 A 对象后，B 创建成功，存入一级缓存。** 

   - Bean B 成功从二级缓存获取了 Bean A 的早期引用，完成了属性注入。

   - Bean B 的初始化过程继续进行，直到完成。

   - Bean B 创建成功，被移入一级缓存。

   -  **此时：** 一级缓存有 B。二级缓存有早期 A。三级缓存有 A 和 B 的 ObjectFactory。

6.  **A 对象初始化时，由于 B 已创建完成，可以直接注入 B，A 创建成功存入一级缓存。** 

   - Spring 回到 Bean A 的初始化流程。

   - 此时，Bean A 需要注入 Bean B。Spring 会去一级缓存查找 Bean B。

   - 找到了！因为 Bean B 已经在上一步创建完成并放入了一级缓存。

   - Bean A 成功注入 Bean B，完成自身的初始化。

   - Bean A 创建成功，被移入一级缓存。

   -  **此时：** 一级缓存有 A 和 B。二级缓存有早期 A。三级缓存有 A 和 B 的 ObjectFactory。

7.  **清除二级缓存中的临时对象 A。** 

   - 循环依赖已经解决，Bean A 和 Bean B 都已经成功创建并放入一级缓存。

   - 二级缓存中的早期 Bean A 已经完成了它的“历史使命”，可以被清除了。

   -  **最终：** 一级缓存有 A 和 B。二级缓存为空。三级缓存可能还保留着 ObjectFactory，但随着 Bean 的创建完成，它们也会逐渐被清理。

**表格展示流程：** 

|  **步骤**  |  **操作**  |  **缓存状态**  |
|:---:|:---:|:---:|
| 1 | 实例化 A，创建 ObjectFactory 存入三级缓存。 | 一级缓存：无；二级缓存：无；三级缓存：A 的 ObjectFactory。 |
| 2 | A 初始化需要 B，开始创建 B。 | 一级缓存：无；二级缓存：无；三级缓存：A 的 ObjectFactory。 |
| 3 | 实例化 B，创建 ObjectFactory 存入三级缓存。 | 一级缓存：无；二级缓存：无；三级缓存：A 和 B 的 ObjectFactory。 |
| 4 | B 需要 A，通过三级缓存获取 A 的早期引用，存入二级缓存。 | 一级缓存：无；二级缓存：早期 A；三级缓存：A 和 B 的 ObjectFactory。 |
| 5 | B 完成初始化，存入一级缓存。 | 一级缓存：B；二级缓存：早期 A；三级缓存：A 和 B 的 ObjectFactory。 |
| 6 | A 完成初始化，存入一级缓存。 | 一级缓存：A 和 B；二级缓存：早期 A；三级缓存：A 和 B 的 ObjectFactory。 |
| 7 | 清除二级缓存中的临时对象 A。 | 一级缓存：A 和 B；二级缓存：无；三级缓存：A 和 B 的 ObjectFactory。 |


通过这个巧妙的流程，Spring 利用三级缓存作为“中转站”，在 Bean 尚未完全初始化的情况下，提供一个早期引用给依赖它的 Bean，从而打破了循环依赖的僵局。

---

## 构造方法循环依赖

尽管 Spring 的三级缓存机制非常强大，但它并不能解决所有类型的循环依赖。一个典型的例子就是 **构造方法出现了循环依赖** 。

### 为什么构造方法循环依赖 Spring 解决不了呢？

因为构造方法是 Bean 生命周期中 **最先执行** 的部分。在执行构造方法时，Bean 甚至还没有被实例化，更谈不上创建 ObjectFactory 并存入三级缓存了。如果两个 Bean 在构造方法中就互相依赖，Spring 根本无法在它们实例化之前提供任何形式的早期引用。

>  **类比：** 就像你正在建造两栋房子，房子 A 的地基需要房子 B 的一个关键构件，而房子 B 的地基也需要房子 A 的一个关键构件。在房子连地基都还没打好的时候，你无法从任何地方获得对方的构件，建造过程就无法开始。

### 如何解决构造方法的循环依赖？

在这种情况下，我们需要调整 Bean 的设计，打破构造方法中的循环依赖。一种常用的方法是使用 **`@Lazy` 懒加载注解** 。

- 在其中一个 Bean 的构造方法依赖上添加 `@Lazy` 注解。

- 例如，如果 Bean A 的构造方法依赖 Bean B，可以在 Bean B 的注入点（构造方法参数）上加上 `@Lazy` 。

```java
@Component
public class BeanA {
    private final BeanB beanB;

    // 构造方法依赖 BeanB
    public BeanA(@Lazy BeanB beanB) {
        this.beanB = beanB;
        System.out.println("BeanA 构造方法执行");
    }
    // ... 其他方法
}

@Component
public class BeanB {
    private final BeanA beanA;

    // 构造方法依赖 BeanA
    public BeanB(BeanA beanA) {
        this.beanA = beanA;
        System.out.println("BeanB 构造方法执行");
    }
    // ... 其他方法
}
```

通过 `@Lazy` 注解，Spring 会延迟 Bean B 的创建，直到 Bean A 真正需要使用它的时候（例如，调用 Bean A 的某个方法时）。这样就避免了在构造方法阶段就形成循环依赖。

---

## 总结

Spring 的循环依赖解决机制是其 IoC 容器设计中的一个亮点，通过巧妙地运用三级缓存，Spring 能够处理大部分的 Bean 循环依赖问题。然而，对于构造方法引起的循环依赖，我们需要通过 `@Lazy` 等方式手动干预，优化 Bean 的设计。

| 概念/机制 | 描述 | 关键点/作用 | 解决方式/备注 |
|:---|:---|:---|:---|
|  **什么是循环依赖？**  | 两个或两个以上的 Bean 互相持有对方的引用，形成闭环。 | 例如：Bean A 需要 Bean B，同时 Bean B 也需要 Bean A。 | Spring 大部分情况下可以解决单例 Bean 的循环依赖。 |
|  **核心解决机制**  |  **三级缓存机制**  | Spring 利用三个不同作用的缓存来打破循环依赖。 | 主要针对 **属性注入 (Setter/Field Injection)** 方式的循环依赖。 |
|  **一级缓存 (L1)**  |  `singletonObjects` (单例池) | 存放 **完全初始化** 、可直接使用的单例 Bean 对象。 | 相当于“成品仓库”。 |
|  **二级缓存 (L2)**  |  `earlySingletonObjects` (早期 Bean 缓存) | 存放 **实例化完成，但尚未完成属性注入和初始化** 的早期 Bean 对象。 | 相当于“半成品仓库”，用于临时存放，供依赖方提前引用。 |
|  **三级缓存 (L3)**  |  `singletonFactories` (ObjectFactory 缓存) | 存放用于创建早期 Bean 的 `ObjectFactory` 。 `getObject()` 方法可以延迟生成早期 Bean 实例。 | 相当于“生产指令仓库”，是解决循环依赖的 **关键** ，提供了获取早期 Bean 的能力。 |
|  **解决流程 (A, B 循环)**  | 实例化 A -> A 的 ObjectFactory 入 L3 -> A 需 B -> 开始创建 B -> 实例化 B -> B 的 ObjectFactory 入 L3 -> B 需 A -> 从 L3 取 A 的 ObjectFactory -> 生成早期 A 入 L2 -> B 使用 L2 的早期 A 完成注入 -> B 完成初始化入 L1 -> A 从 L1 取 B 完成注入 -> A 完成初始化入 L1 -> 清理 L2 中的早期 A。 | 通过 L3 的 ObjectFactory 和 L2 的早期 Bean，在 Bean 未完全初始化前提供引用，打破僵局。 | 这是一个简化流程，体现了核心思想。 |
|  **特殊情况**  |  **构造方法循环依赖**  | Bean 在构造方法中互相依赖。 |  **Spring 无法解决** ，因为构造方法在实例化之前执行，L2/L3 机制无法介入。 |
|  **构造方法循环解决**  | 使用 `@Lazy` 注解。 | 在其中一个 Bean 的构造方法依赖参数上添加 `@Lazy` ，延迟该 Bean 的创建和注入，直到实际使用时。 | 需要修改代码结构，避免在构造方法中直接循环依赖。 |