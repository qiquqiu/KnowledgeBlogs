# 【多线程篇11】：关于sychronized锁升级精简小结

> 原创 于 2025-07-16 10:19:03 发布 · 公开 · 298 阅读 · 10 · 2 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149389351

Java 中的 `synchronized` 关键字用于实现线程同步，确保同一时间只有一个线程能访问受保护的资源。它采用动态锁升级机制，根据线程竞争激烈程度逐步提升锁级别以优化性能：

1.  **偏向锁 (Biased Locking)** ：

   - 初始锁状态，适用于单线程访问场景

   - 首次访问同步块时，线程获取偏向锁并在对象头 **Mark Word** 中记录线程ID（64位JVM中占54位）

   - 同一线程再次访问时直接检查线程ID匹配，无需同步操作，减少CAS开销

   - 典型应用场景：单线程重复调用同步方法

   - 当其他线程尝试获取锁时，JVM会暂停持有偏向锁的线程，撤销偏向锁并升级为轻量级锁

2.  **轻量级锁 (Lightweight Locking)** ：

   - 适用于多线程交替访问但无实际竞争的场景（如线程A和B交替执行）

   - 线程在栈帧创建Lock Record空间，存储对象头原始Mark Word的拷贝

   - 通过CAS操作尝试将对象头指向该锁记录

   - 成功则获取轻量级锁，失败则触发自旋（默认10次，可通过-XX:PreBlockSpin调整）

   - 自旋失败后升级为重量级锁

   - 解锁时同样使用CAS将对象头恢复为Lock Record中保存的Mark Word

3.  **重量级锁 (Heavyweight Locking)** ：

   - 处理高并发竞争场景（如100个线程同时竞争）

   - 基于操作系统互斥量(Mutex)，涉及用户态到内核态的上下文切换（每次切换约5-10微秒）

   - 未获取锁的线程进入阻塞状态，加入ObjectMonitor的_WaitSet队列

   - 唤醒线程时通过操作系统的线程调度机制实现

   - 典型应用场景：热点代码段或长时间持有的同步块

**锁升级完整流程** ：

1. 对象刚创建时处于无锁状态（锁标志位 **01** ）

2. 第一次线程访问时升级为偏向锁（标志位 **01** +偏向模式1）

3. 出现第二个线程访问时撤销偏向锁，转为轻量级锁（标志位 **00** ）

4. 自旋超过阈值或第三个线程加入竞争时升级为重量级锁（标志位 **10** ）

>  **锁降级说明** ：
> 虽然锁升级通常是单向过程，但在特定情况下（如JVM安全点检测到无活跃线程持有锁时），重量级锁可能降级为轻量级锁。典型场景包括：
> 
> 

- 长时间空闲的线程池

- 系统负载骤降时

- 通过JVM参数-XX:+UseHeavyMonitors控制

通过这种动态调整机制， `synchronized` 能在不同竞争环境下保持最佳性能：低竞争时使用轻量级锁减少开销，高竞争时采用重量级锁确保线程安全