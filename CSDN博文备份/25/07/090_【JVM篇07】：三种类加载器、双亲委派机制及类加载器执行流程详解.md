# 【JVM篇07】：三种类加载器、双亲委派机制及类加载器执行流程详解

> 原创 于 2025-07-28 07:30:00 发布 · 公开 · 1.1k 阅读 · 20 · 18 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149698024

**文章目录**

[TOC]



## 1. 什么是类加载器？

首先，要理解类加载器，我们需要知道Java 程序是如何运行的。我们写的 `.java` 文件会被编译成 `.class` 文件（字节码），这些字节码是JVM(Java 虚拟机) 能够理解的指令

**类加载器 (ClassLoader)** 的核心职责就是：

1.  **找到** `.class` 文件

2.  **读取** `.class` 文件的字节码内容

3. 将这些字节码 **转换** 成 JVM 内部的 `java.lang.Class` 对象，并加载到内存中

4. 为这个 `Class` 对象进行 **链接** （验证、准备、解析）和 **初始化** ，最终使类可以被使用

如果没有类加载器，JVM 就无法识别和运行我们的 Java 代码

---

## 2. 类加载器的“三层结构”和“双亲委派模型”

Java 有一个层次结构的类加载器，就像一个公司里的不同部门，各司其职，并且有一个明确的汇报关系

1.  **Bootstrap ClassLoader (启动类加载器)** ：

   -  **地位：** 最高层级，最“资深”的员工

   -  **实现：** 由 C++ 实现，不是 Java 类，所以你不能在 Java 代码中直接引用它（ `null` 作为其父加载器）

   -  **职责：** 加载 JVM 运行所必需的 **最核心、最基础** 的 Java 类库。这些类是 JVM 自身运行的基石，如 `java.lang.Object` 、 `String` 、 `ArrayList` 等，它们定义了 Java 语言最基本的功能和数据结构

2.  **Extension ClassLoader (扩展类加载器)** ：

   -  **地位：** 第二层级，是 Bootstrap ClassLoader 的“直接下属”

   -  **实现：** 由 Java 编写，继承自 `ClassLoader` 

   -  **职责：** 加载 Java 的 **扩展库** 。在 JDK 8 及以前，它们通常位于 `<JAVA_HOME>/lib/ext` 目录下。在 JDK 9+ 的模块化时代，它的作用被大大削弱，主要用于兼容一些非模块化的遗留扩展JAR包

3.  **Application ClassLoader (应用程序类加载器 / 系统类加载器)** ：

   -  **地位：** 最底层，是 Extension ClassLoader 的“直接下属”

   -  **实现：** 由 Java 编写，继承自 `ClassLoader` 

   -  **职责：** 加载 **应用程序自身** 的类（你写的代码）以及 **第三方库** （你项目中引入的各种 JAR 包）。它会从 `classpath` 指定的路径中加载这些类

### 双亲委派模型

这是一个非常重要的工作流程。当一个类加载器收到加载某个类的请求时，它不会直接去加载，而是：

1.  **向上委派：** 首先把这个请求 **委派给它的父类加载器** 

2.  **逐级向上：** 如果父类加载器还有父类加载器，就继续向上委派，直到最终委派到 **Bootstrap ClassLoader** 

3.  **向下加载：** 只有当父类加载器（包括 Bootstrap ClassLoader）都无法加载这个类时，当前的类加载器才会尝试自己去加载这个类

**为什么要这么设计？** 

-  **避免重复加载：** 确保一个类只被加载一次

-  **安全机制：** 防止恶意代码替换核心类库。例如，如果你写了一个 `java.lang.String` 类并试图加载它，由于双亲委派机制，请求会先到 Bootstrap ClassLoader，它发现自己已经加载过真正的 `java.lang.String` ，就不会再向下委派，从而保证了核心 API 的安全和一致性

---

## 3. 类加载器工作流程详解 (什么时候 Bootstrap ClassLoader 会加载？)

现在我们来模拟一个完整的 Java 应用程序启动和类加载的流程：

**假设运行一个简单的 Java 程序：** 

`MyApplication.java` :

```java
package com.example;

import java.util.ArrayList; // 依赖核心库的类
import com.mylib.StringUtils; // 依赖第三方库的类

public class MyApplication {
    public static void main(String[] args) {
        System.out.println("Hello, ClassLoaders!"); // 依赖java.lang.System
        ArrayList<String> list = new ArrayList<>(); // 使用ArrayList
        String result = StringUtils.concatenate("Hello", "World"); // 使用第三方库
        System.out.println(result);
    }
}
```

**运行命令 (IDEA会生成类似命令):** 

`java -cp /path/to/my/project/target/classes:/path/to/mylib.jar com.example.MyApplication` 

---

### 类加载器工作流程步骤

**步骤 1: 启动 JVM，加载应用程序入口类** 

1. 当你执行 `java com.example.MyApplication` 命令时，JVM 启动

2. JVM 首先需要找到并加载 `com.example.MyApplication` 这个类

3. 这个请求会首先被交给 **Application ClassLoader** (因为它负责加载应用程序的类)

**步骤 2: Application ClassLoader 收到请求，向上委派** 

1. Application ClassLoader 收到加载 `com.example.MyApplication` 的请求

2.  **按照双亲委派模型，它不直接加载，而是将请求委派给它的父加载器：Extension ClassLoader** 

**步骤 3: Extension ClassLoader 收到请求，继续向上委派** 

1. Extension ClassLoader 收到加载 `com.example.MyApplication` 的请求

2.  **它也继续向上委派，将请求交给它的父加载器：Bootstrap ClassLoader** 

**步骤 4: Bootstrap ClassLoader 尝试加载 (核心库优先)** 

1.  **Bootstrap ClassLoader** 收到加载 `com.example.MyApplication` 的请求

2. 它开始在自己负责的路径（即 `lib/modules` 文件和 `jmods` 目录等核心模块路径）中查找 `com.example.MyApplication.class` 

3.  **结果：** `com.example.MyApplication` 是你自己的应用程序类，它不在 Java 核心库中。所以， **Bootstrap ClassLoader 找不到这个类，无法加载** 

**步骤 5: 请求向下返回，Extension ClassLoader 尝试加载** 

1. 由于 Bootstrap ClassLoader 无法加载，加载请求会退回到 **Extension ClassLoader** 

2. Extension ClassLoader 开始在自己负责的路径（作用不大，但理论上会检查 `java.ext.dirs` 等）中查找 `com.example.MyApplication.class` 

3.  **结果：** `com.example.MyApplication` 也不是 Java 扩展库中的类。所以， **Extension ClassLoader 找不到这个类，无法加载** 

**步骤 6: 请求再次向下返回，Application ClassLoader 最终加载** 

1. 由于 Extension ClassLoader 也无法加载，加载请求最终退回到最初的 **Application ClassLoader** 

2. Application ClassLoader 现在知道它的“上级”都搞不定了，就自己开始干活。它会在你通过 `-classpath` 参数指定的路径（即 `myproject\target\classes` ）中查找 `com.example.MyApplication.class` 

3.  **结果：** 它找到了！于是，Application ClassLoader 读取 `MyApplication.class` 的字节码，将其加载到内存，生成 `java.lang.Class` 对象

**步骤 7: `MyApplication` 类被加载，开始执行 `main` 方法，并触发其他类的加载** 

1.  `MyApplication` 类被成功加载和初始化后，JVM 调用它的 `main` 方法

2. 在 `main` 方法中，程序会执行到 `System.out.println(...)` 

   - 这会触发对 `java.lang.System` 类和 `java.io.PrintStream` 类的加载请求

   -  **加载 `java.lang.System` 的过程：** 请求会从 Application ClassLoader 委派到 Extension ClassLoader，再委派到 **Bootstrap ClassLoader** 。 **Bootstrap ClassLoader 会在 `lib/modules` 等核心模块路径中找到 `System.class` ，并成功加载它** 

3. 接着，程序执行到 `ArrayList<String> list = new ArrayList<>();` 

   - 这会触发对 `java.util.ArrayList` 类的加载请求

   -  **加载 `java.util.ArrayList` 的过程：** 同样，请求会从 Application ClassLoader 委派到 Extension ClassLoader，再委派到 **Bootstrap ClassLoader** 。 **Bootstrap ClassLoader 会在 `lib/modules` 等核心模块路径中找到 `ArrayList.class` ，并成功加载它** 

4. 最后，程序执行到 `StringUtils.concatenate(...)` 

   - 这会触发对 `com.mylib.StringUtils` 类的加载请求

   -  **加载 `com.mylib.StringUtils` 的过程：** 请求会从 Application ClassLoader 委派到 Extension ClassLoader，再委派到 Bootstrap ClassLoader

   - Bootstrap ClassLoader 找不到（因为它不是核心库）

   - Extension ClassLoader 找不到（因为它不是扩展库）

   - 请求退回到 **Application ClassLoader** 。Application ClassLoader 在其 `classpath` 中的 `/path/to/mylib.jar` 中找到 `com.mylib.StringUtils.class` ，并成功加载它

---

## 总结：Bootstrap ClassLoader 何时加载？它加载什么？

-  **何时加载？** 

  - Bootstrap ClassLoader 在 **JVM 启动时就被创建** 

  - 它会在 **任何其他类加载器尝试加载类之前** ，优先被委派去加载类

  - 只要有类需要加载，无论是你自己的类还是核心库的类， **加载请求都会最先传递到 Bootstrap ClassLoader** 

-  **它会加载什么？** 

  - 它只加载 **JVM 运行所必需的最核心的 Java 类库** 。这些是构成 Java 语言和平台基础的类

  - 以 JDK 11 环境为例，这些类文件位于：

    -  `lib\modules` (这个文件包含了所有核心模块的编译类)

    - 以及 `jmods` 目录下的 `.jmod` 文件中

  - 例如： `java.lang.*` (如 `Object` , `String` , `System` ), `java.util.*` (如 `ArrayList` , `HashMap` ), `java.io.*` , `java.net.*` 等等，以及 JVM 内部使用的其他核心类

**简而言之，所有 Java 标准库中的类，最终都是由 Bootstrap ClassLoader 来加载的** 