# 【多线程篇06】：详解wait()和sleep()方法的区别对比

> 原创 于 2025-07-12 13:33:50 发布 · 公开 · 564 阅读 · 14 · 8 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149293165

**文章目录**

[TOC]


`wait()` 和 `sleep()` 作用相似，它们都能让线程暂停执行，但其背后的机制和设计目的却截然不同，下面，我们从五个核心维度，彻底剖析它们的区别与联系

## 一、 核心区别速览表

| 特性维度 |  `Object.wait()`  |  `Thread.sleep()`  |
|:---|:---|:---|
|  **1. 归属类**  |  `java.lang.Object` 类的方法 |  `java.lang.Thread` 类的静态方法 |
|  **2. 锁的处理**  |  **会释放** 当前持有的监视器锁（Monitor Lock） |  **不会释放** 任何已持有的锁 |
|  **3. 使用前提**  |  **必须在 `synchronized` 同步代码块或方法中** 调用 | 可以在任何地方调用 |
|  **4. 唤醒方式**  | 需被其他线程通过 `notify()` / `notifyAll()` 或 `interrupt()` 唤醒，或等待超时 | 睡眠时间到期后自动唤醒，或被 `interrupt()` 提前唤醒 |
|  **5. 状态转换**  |  `RUNNABLE` -> `WAITING` / `TIMED_WAITING` -> **`BLOCKED`** -> `RUNNABLE`  |  `RUNNABLE` -> `TIMED_WAITING` -> `RUNNABLE`  |


---

## 二、 核心区别详解

### 1. 归属类不同：设计思想的根源

-  **`sleep()`** : 属于 `Thread` 类，并且是 `static` 方法 ( `Thread.sleep(long millis)` ）。这体现了它的设计意图： `sleep` 是一个 **控制线程自身行为** 的工具，让“当前”线程暂停一下，它不关心其他线程的状态。调用 `sleep` 的主体是线程

-  **`wait()`** : 属于 `Object` 类，是实例方法。这体现了它的设计意图： `wait` 是 **线程间通信和协作** 的工具，它总是与一个 **对象锁（监视器）** 关联。线程不是凭空等待，而是 **在某个对象上等待** ，等待这个对象上的某个条件成立。调用 `wait` 的主体是线程，但等待的对象是锁对象

### 2. 锁的处理机制完全不同 (面试最核心考点)

这是两者最本质的区别，直接决定了它们的使用场景

-  **`wait()` 会释放锁** ：当一个线程在 `synchronized` 代码块中调用了某个对象的 `wait()` 方法，它会 **立即释放掉它在该对象上持有的监视器锁** 。这非常关键，因为释放锁使得其他线程有机会进入同一个 `synchronized` 代码块，去修改条件，并最终通过 `notify()` / `notifyAll()` 唤醒等待的线程

-  **`sleep()` 不会释放锁** ：当一个线程在 `synchronized` 代码块中调用了 `sleep()` 方法，它虽然暂停了执行，进入 `TIMED_WAITING` 状态，但它 **依然持有该对象的监视器锁** 。在此期间，其他任何需要获取该锁的线程都只能进入 `BLOCKED` 状态等待，直到 `sleep` 的线程醒来并执行完同步代码块，释放锁

>  **注意** ：如果在 `synchronized` 代码块中滥用 `sleep()` ，可能会导致其他线程长时间阻塞，造成系统性能问题，甚至死锁

### 3. 使用前提不同

这个区别是上一点“锁处理机制”的直接结果

-  **`wait()` 必须在同步上下文中调用** ：因为 `wait()` 的核心是释放和等待锁，所以它必须首先持有这个锁。因此，调用 `obj.wait()` 的代码必须被 `synchronized(obj)` 代码块包围。如果没有在同步块中调用，JVM会直接抛出 `IllegalMonitorStateException` 

-  **`sleep()` 可以在任何地方调用** ： `sleep()` 只是让当前线程暂停，不涉及任何锁的交互，所以它可以在程序的任何地方被调用

### 4. 唤醒方式不同

-  **`wait()` 是被动唤醒** ：

  1. 其他线程在同一个对象上调用 `notify()` 或 `notifyAll()` 

  2. 其他线程调用了该等待线程的 `interrupt()` 方法

  3. 如果调用的是 `wait(long timeout)` ，等待时间超时
      `wait()` 的线程不能自己决定何时醒来，它依赖于外部的“通知”

-  **`sleep()` 是主动唤醒** ：

  1. 指定的睡眠时间到期

  2. 其他线程调用了该睡眠线程的 `interrupt()` 方法
      `sleep()` 的线程醒来的主要条件是时间，是可预期的

---

## 三、 联系与共同点

尽管区别巨大，但它们也有一个重要的共同点：

-  **都会抛出 `InterruptedException`** ： `wait()` 和 `sleep()` 都可以被 `interrupt()` 方法中断。当一个线程在 `wait()` 或 `sleep()` 期间被中断，它会抛出 `InterruptedException` 并被唤醒，同时清除中断标志位。因此，调用这两个方法都必须处理这个受检异常

---

## 四、总结

1.  **总述** ： `wait()` 和 `sleep()` 都能让线程暂停，但它们的设计目的和核心机制完全不同

2.  **第一核心点（锁）** ：“最本质的区别在于对锁的处理。 `wait()` 方法会释放当前线程持有的对象锁，这样其他线程才能进入同步块去改变条件。而 `sleep()` 方法则不会释放任何它持有的锁，它只是抱着锁睡着了”

3.  **第二核心点（归属与前提）** ：“这个区别也导致了它们的归属和使用前提不同。 `wait()` 是 `Object` 类的方法，必须在 `synchronized` 代码块中调用，否则会抛出 `IllegalMonitorStateException` 。而 `sleep()` 是 `Thread` 类的静态方法，可以在任何地方使用”

4.  **第三核心点（目的与唤醒）** ：“从设计目的上看， `wait()` 主要用于线程间的通信和协作，它需要等待某个条件成立，因此需要被 `notify()` 或 `notifyAll()` 唤醒。而 `sleep()` 纯粹是为了让线程暂停一段时间，时间到了就会自动醒来”

5.  **总结共同点** ：“共同点是都可以被 `interrupt()` 方法中断，并抛出 `InterruptedException` ”

