# 【集合篇02】：深入理解HashMap原理、冲突与优化

> 原创 于 2025-07-06 09:00:00 发布 · 公开 · 522 阅读 · 11 · 15 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149143938

**文章目录**

[TOC]



## HashMap 的底层数据结构

HashMap 的底层主要采用了 **哈希表（Hash Table)** 的数据结构哈希表是一种通过哈希函数将键（Key）映射到数组下标，从而实现快速查找的数据结构具体来说，HashMap 的底层是 **数组和链表（或红黑树）** 的结合

你可以想象成一个大数组，数组的 **每一个位置可以看作是一个“桶”（bucket）或“槽”（slot）** 当我们往 HashMap 中存储一个键值对时，会根据键计算出一个哈希值，然后将这个哈希值映射到数组的某个下标位置

---

## 哈希函数与散列冲突

**哈希函数** 是 HashMap 工作中的核心它的作用是将任意的键（Key）转换为一个非负整数，这个整数就是哈希值然后，HashMap 会通过一定的计算（通常是哈希值与数组长度取模）将哈希值映射到数组的下标

一个好的哈希函数应该满足以下基本要求：

> 

-  **非负整数：** 计算得到的哈希值必须是非负整数，因为它是作为数组的下标使用的

-  **等价键产生相同哈希值：** 如果两个键是相等的（根据 `equals()` 方法判断），那么它们经过哈希函数计算后得到的哈希值也必须相同

-  **不等价键尽量产生不同哈希值：** 理想情况下，不同的键应该产生不同的哈希值

然而，在实际应用中，很难找到一个完美的哈希函数，能够保证不同的键都产生不同的哈希值 **散列冲突（Hash Collision）** ，也称为哈希冲突或哈希碰撞，就是指两个或多个不同的键经过哈希函数计算后，得到了相同的哈希值，从而映射到了数组的同一个下标位置

---

## 散列冲突的解决：链表法（JDK1.8之前）

HashMap 解决散列冲突的主要方法是 **链表法** 当多个键映射到同一个数组下标时，HashMap 不会覆盖之前的数据，而是在这个下标位置上挂载一个链表，将所有哈希值相同的键值对都存储在这个链表中

简单来说，数组的每一个“桶”不再只存储一个元素，而是存储一个链表的头节点所有哈希到同一个桶的元素，都会被添加到这个链表中

---

## HashMap 的基本操作：Put 与 Get

理解了底层结构和冲突解决方式，我们就可以看看 HashMap 的基本操作是如何进行的：

**Put 操作（存储元素）：** 

1. 当我们调用 `put(key, value)` 方法时，HashMap 会首先利用 `key` 的 `hashCode()` 方法计算出键的哈希值

2. 然后，通过一定的计算（通常是哈希值与当前数组长度进行位运算或取模），将哈希值映射到数组的一个下标位置

3. 接着，HashMap 会检查这个下标位置

   -  **如果该位置为空** ，说明没有冲突，直接将新的键值对封装成一个节点存储在这里

   -  **如果该位置不为空** ，说明发生了 **冲突** ，此时，HashMap 会遍历该位置上的链表

     - 如果在链表中找到了一个与当前 `key` 相等的键（通过 `equals()` 方法判断），则用新的 `value` 覆盖旧的 `value` 

     - 如果在链表中没有找到与当前 `key` 相等的键，则将新的键值对添加到链表的末尾（或者头部，取决于具体实现）

**Get 操作（获取元素）：** 

1. 当我们调用 `get(key)` 方法时，同样会利用 `key` 的 `hashCode()` 方法计算出哈希值

2. 通过相同的映射规则，将哈希值映射到数组的下标位置

3. 然后，HashMap 会访问这个下标位置

   - 如果该位置为空，说明该 `key` 不存在于 HashMap 中，返回 `null` 

   - 如果该位置不为空，说明可能存在该 `key` 此时，HashMap 会遍历该位置上的链表，逐个比较链表中的节点的键与要查找的 `key` 是否相等（通过 `equals()` 方法判断）

     - 如果找到了相等的键，则返回对应的值

     - 如果遍历完整个链表都没有找到相等的键，说明该 `key` 不存在于 HashMap 中，返回 `null` 

---

### 时间复杂度分析

在理想情况下，即没有散列冲突发生时， `put` 、 `get` 和 `remove` 等操作的时间复杂度都是 ***O(1)*** ，因为我们只需要通过哈希函数计算出下标，然后直接访问数组即可

然而，当散列冲突严重时，一个数组下标位置上的链表会变得很长此时， `put` 、 `get` 和 `remove` 操作就需要遍历链表，时间复杂度会退化为 **O(n)** ，其中 n 是链表的长度这会显著降低 HashMap 的性能

---

## JDK1.8 对 HashMap 的优化：引入红黑树

为了解决链表过长导致的性能下降问题，JDK1.8 对 HashMap 的实现进行了重要的优化： **当链表长度达到一定阈值（默认为 *8* ）并且数组长度也达到一定阈值（默认为 *64* ）时，会将该位置的链表转换为红黑树（Red-Black Tree）** 

红黑树是一种 **自平衡的二叉查找树** ，它的查找、插入和删除操作的时间复杂度都是 `O(logn)` 通过将长链表转换为红黑树，HashMap 在发生严重散列冲突时，其查找性能可以从 `O(n)` 提升到 `O(logn)` 

### 为什么需要同时满足链表长度和数组长度的阈值才进行转换？

-  **链表长度阈值：** 这是为了避免频繁的链表与红黑树之间的转换当链表长度较小时，使用链表已经足够高效，转换成红黑树反而会增加额外的开销

-  **数组长度阈值：** 这是为了避免在数组容量较小的情况下就进行红黑树转换在数组容量较小时，即使链表长度达到 8，发生冲突的概率也相对较高通过扩容来增加数组容量通常是更有效的解决冲突的方式只有当数组容量足够大，冲突仍然严重时，才考虑将链表转换为红黑树

### 红黑树的退化

在HashMap 扩容（resize）时，如果红黑树拆分成的树的节点数小于等于临界值 6 个，则会退化回链表这是为了避免在节点数较少的情况下维护红黑树的开销，此时链表已经足够高效

---

## HashMap 与 DDoS 攻击的关联

将链表转换为红黑树的另一个重要原因，是为了防止 **DDoS 攻击（分布式拒绝服务攻击）** 

在 JDK1.8 之前，如果攻击者精心构造一些具有相同哈希值的键，并大量地插入到 HashMap 中，会导致某个桶上的链表变得非常长此时，正常的 `get` 操作就需要遍历这个超长链表，使得服务器的 CPU 资源被大量消耗，从而导致服务不可用

引入红黑树后，即使攻击者构造了大量具有相同哈希值的键，这些键值对也会被组织成一棵红黑树，查找的时间复杂度为 O(logn)，显著降低了攻击的影响

---

## JDK1.7 与 JDK1.8 HashMap 的主要区别总结

-  **解决哈希冲突的方式：** 

  - JDK1.7：主要使用链表法

  - JDK1.8：在链表长度达到阈值且数组长度达到阈值时，将链表转换为红黑树

-  **数据结构：** 

  - JDK1.7：数组 + 链表

  - JDK1.8：数组 + 链表 或 红黑树

