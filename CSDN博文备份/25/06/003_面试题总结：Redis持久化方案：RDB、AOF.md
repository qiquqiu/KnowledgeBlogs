# 面试题总结：Redis持久化方案：RDB、AOF

> 原创 已于 2025-06-12 11:55:41 修改 · 公开 · 663 阅读 · 6 · 8 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/148606461

**目录**

[TOC]



## 概念

> 

1. 在Redis中提供了两种数据持久化的方式： （1） **RDB** ； （2） **AOF** 

2.  **RDB (Redis DataBase)：** 创建 **内存数据的二进制快照** 文件（ `.rdb` )。 **手动触发** （ `SAVE` / `BGSAVE` ) 或 **自动触发** （配置 `save <seconds> <changes>` ）。

3.  **AOF (Append Only File)：** 记录 **所有写操作命令** （文本协议格式）。命令先写入内存缓冲区，再根据 `appendfsync` 策略写入磁盘文件。

## 对比速记

|  **对比项**  |  **RDB**  |  **AOF**  |
|:---:|:---:|:---:|
|  **持久化方式**  | 定时对 **整个内存** 做快照 | 记录每一次执行的命令 |
|  **数据完整性**  |  **不完整** ，两次备份之间会丢失 |  **相对完整** ，取决于刷盘策略 |
|  **文件大小**  | 会有压缩，文件体积小 | 记录命令，文件体积很大 |
|  **宕机恢复速度**  |  **很快**  |  **慢**  |
|  **数据恢复优先级**  |  **低** ，因为数据完整性不如 AOF |  **高** ，因为数据完整性更高 |
|  **系统资源占用**  | 高，大量 CPU 和内存消耗 | 低，主要是磁盘 IO 资源；但 **AOF 重写** 时会占用大量 CPU 和内存资源 |
|  **使用场景**  | 可以容忍数分钟的数据丢失，追求更快的启动速度 | 对数据安全性要求较高场景 |


## 场景类比

> ### 🍔快餐店类比

1.  **RDB（快照）** 
>    相当于给餐厅拍张营业开始时的照片（冷柜库存、收银台金额）
> 
>    - 优点：恢复时直接按照片摆货（恢复极快）
> 
>    - 缺点：两个时间段卖掉的汉堡（数据变更）会丢失
> 
>    - 发生交易数据丢失情况举例：
> 
>    - | 时间 | 操作 | 数据状态 | RDB快照影响 |
>      |:---:|:---:|:---:|:---:|
>      |  **10:00**  | 开店拍照（RDB生成） | 冷柜：100个汉堡；收银台：0元 | 快照A：保存 `[100, 0]`  |
>      |  **12:00**  | 卖出30个汉堡 | 冷柜：70个；收银台：300元 |  **未触发拍照，数据在内存**  |
>      |  **15:00**  | 系统崩溃（停电） | 内存数据丢失 |  |
>      |  **15:01**  | 重启恢复（加载快照A） | 冷柜：100个；收银台：0元 |  **丢失12:00~15:00的所有交易**  |
> 
> 

2.  **AOF（操作日志）** 
>    相当于记录每一笔订单小票（"卖出1个汉堡"、"收到20元"）
> 
>    - 优点：用所有小票重放可还原完整营业过程（数据完整性高）
> 
>    - 缺点：要一张张小票处理（恢复慢），且日志可能堆积如山（文件膨胀）
> 
> 

---

## 底层细节

1. ###  **关于“丢数据”和“恢复快”的深入理解** 

   -  **RDB为什么恢复快？** 快照是内存数据的直接二进制映射，加载时直接解析填充内存即可，就像解压一个压缩包。

   -  **RDB为什么可能丢数据？** 快照是 **时间点** 的数据。如果配置为“5分钟内有至少100次写操作”才生成快照，那么宕机时可能丢失最近5分钟内的数据。

   -  **AOF为什么恢复慢？** 需要顺序执行文件中的所有写命令来重建内存数据库。命令越多，文件越大，恢复时间越长。

   -  **AOF如何减少丢数据？** 设置刷盘策略，有不同的记录策略选择：

     - 同步刷盘（性能影响大）

     - 每秒刷盘（最多丢失1s数据）

     - 操作系统控制（可靠性差，可能丢失大量数据）

2. ### “RDB是快照，它是怎么生成的？会对主进程造成阻塞吗？”

   答：Redis使用( `BGSAVE` )命令在后台生成RDB快照。其核心是fork()系统调用。fork()会创建一个与主进程几乎完全相同的子进程。子进程负责将内存数据写入临时RDB文件，完成后替换旧文件。关键点：

   - fork()本身是阻塞的（时间通常很短，纳秒级，忽略不计）。

   - 子进程与父进程共享内存数据。子进程写入的是fork()那一刻的内存快照。

   - 写时复制(Copy-On-Write)： 父进程（处理请求）修改数据时，会复制被修改的内存页给父进程自己用， **子进程看到的还是fork()时的数据** 。这保证了快照一致性，也避免了父进程阻塞。但修改数据会触发内存复制，如果写操作频繁，内存占用会上升。

3. ###  **“AOF文件会越来越大，怎么处理？”** 

    **答：** Redis提供了 **AOF重写(** `BGREWRITEAOF` **)** 机制来解决。其原理是：

   - 创建一个新的AOF文件。

   - 遍历当前数据库的所有键值对，用 **一条命令** （如 `SET` 、 `HSET` ）重建 **当前数据状态** ，而不是记录所有历史命令。

   -  **重写过程也是后台 `fork()` 子进程进行，不影响主进程处理请求。** 完成后替换旧AOF文件。

## 一句话总结

> "Redis持久化有 **RDB快照** 和 **AOF日志** 两种方案。
> 
> RDB恢复快但可能丢数据，适合允许丢失的场景；AOF更可靠但性能开销大。
> 
> Redis通常开启混合持久化，并用AOF重写控制文件体积。
> 
> 我们项目...根据数据类型差异组合使用这两种方式。"