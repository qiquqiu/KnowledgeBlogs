# leetcode2379：得到K个黑块的最少涂色次数（定长滑动窗口）

> 原创 已于 2025-08-10 15:44:16 修改 · 公开 · 727 阅读 · 6 · 18 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/150118314

**文章目录**

[TOC]


[LeetCode2379. 得到 K 个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/) ，【难度：简单；通过率：64.1%】，这道题的巧妙之处在于，它将一个看似需要“涂色操作”的问题，通过思维转换，变成了一个我们非常熟悉的 **“计数”** 问题

## 一、 题目描述

给你一个长度为 `n` ，下标从 0 开始的字符串 `blocks` ， `blocks[i]` 要么是 `'W'` 要么是 `'B'` ，分别表示白色和黑色。同时给你一个整数 `k` ，表示你想要得到的连续黑色块的数目

每一次操作中，你可以选择一个白色块将它涂成黑色

请你返回至少出现一次连续 `k` 个黑色块的 **最少** 操作次数

**示例:** 

**示例 1：** 

```
输入：blocks = "WBBWWBBWBW", k = 7
输出：3

解释：
一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色
得到 blocks = "BBBBBBBWBW"
可以证明无法用少于 3 次操作得到 7 个连续的黑块
所以我们返回 3 
```

**示例 2：** 

```
输入：blocks = "WBWBBBW", k = 2
输出：0

解释：
不需要任何操作，因为已经有 2 个连续的黑块
所以我们返回 0
```

---

## 二、 核心思路：问题转换 + 定长滑动窗口

初看题目，可能会想到模拟涂色。但仔细思考后会发现 **要使一个长度为 `k` 的子串全部变为黑色，需要操作的次数恰好等于这个子串中 <u>白色块</u> ‘W’ 的数量** 

因此，题目就转换成了： **在字符串 `blocks` 中，找到所有长度为 `k` 的子串， <u>哪一个子串</u> 包含的 ‘W’ 字符数量最少？** 

触发关键词： **“子串”** ，可以尝试尝试 **滑动窗口** 来解决，尝试分析一个思路：

1.  **初始化窗口** ：首先，我们创建一个大小为 `k` 的窗口，覆盖字符串的前 `k` 个字符。我们计算出这个初始窗口中 ‘W’ 的数量，并将其作为初始的最小操作次数 `ans` 

2.  **滑动窗口** ：然后，让窗口向右逐格滑动。每次滑动，我们都高效地更新窗口内 ‘W’ 的数量：

   - 如果 **离开窗口** 的左侧字符是 ‘W’，则计数减 1

   - 如果 **进入窗口** 的右侧新字符是 ‘W’，则计数加 1

3.  **更新结果** ：每次滑动后，我们都将当前窗口的 ‘W’ 数量与已知的最小值 `ans` 进行比较，并随时更新 `ans` 

4.  **最终结果** ：遍历完整个字符串后， `ans` 就是所有长度为 `k` 的子串中 ‘W’ 的最少数量，即题目的答案

---

## 三、 代码实现与深度解析

```java
class Solution {
    public int minimumRecolors(String blocks, int k) {
        // 转为字符数组，提高效率
        char[] arr = blocks.toCharArray();
        
        // cnt: 记录当前窗口内白色 ('W') 块的数量
        // l: 窗口的左边界索引
        // ans: 记录到目前为止，所有窗口中白色块的最小数量
        int cnt = 0, l = 0, ans; 

        // 步骤 1: 初始化第一个窗口（从索引 0 到 k-1）
        // 遍历前 k 个字符，计算初始窗口内的白色块数量
        for (int i = 0; i < k; i++) {
            // 如果当前字符是 'W'，则 cnt 加 1
            cnt = arr[i] == 'W' ? cnt + 1 : cnt;
        }

        // 将第一个窗口的白色块数量作为初始的最小操作次数
        ans = cnt;

        // 步骤 2: 滑动窗口遍历剩余的字符串
        // r: 窗口的右边界索引，从 k 开始，直到数组末尾
        // 每次循环，窗口向右滑动一格
        for (int r = k; r < arr.length; r++) {
            // 2.1 处理滑出窗口的左侧字符 (arr[l])
            // 如果 arr[l] 是 'W'，说明一个白色块离开了窗口，cnt 减 1
            // l++ 使左边界向右移动一格，为下一次循环做准备
            cnt = arr[l++] == 'W' ? cnt - 1 : cnt;

            // 2.2 处理滑入窗口的右侧字符 (arr[r])
            // 如果 arr[r] 是 'W'，说明一个白色块进入了窗口，cnt 加 1
            cnt = arr[r] == 'W' ? cnt + 1 : cnt;

            // 2.3 更新最小操作次数
            // 每次窗口滑动完成后，当前窗口的白色块数量 (cnt) 可能是一个新的最小值
            // 将其与之前记录的 ans 比较，取较小值
            ans = Math.min(ans, cnt);
        }

        // 步骤 3: 返回最终结果
        // 循环结束后，ans 就存储了所有长度为 k 的子串中白色块的最少数量，
        // 这也正是题目所求的最少操作次数
        return ans;
    }
}

```

提交结果：
 ![在这里插入图片描述](./assets/117_1.png)

## 四、 关键点与复杂度分析

-  **思维转换** ：本题的关键在于将“最少操作次数”等价于“定长子串中最少的 ‘W’ 数量”

-  **定长滑动窗口** ：这是解决此类问题的标准模板，通过 O(1) 的更新操作，避免了对每个子串的重复计算

-  **时间复杂度** ： **O(N)** 其中 N 是字符串 `blocks` 的长度。我们只需要遍历一次字符串

-  **空间复杂度** ： **O(1)** 或 O(N) 如果将 `toCharArray()` 的开销计算在内，则为 O(N)；如果不计，则只使用了常数个额外变量，为 O(1)

