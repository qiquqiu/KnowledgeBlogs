# leetcode199：（层序遍历）二叉树的右视图

> 原创 于 2025-08-03 07:15:00 发布 · 公开 · 626 阅读 · 26 · 12 · CC 4.0 BY-SA版权 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
> 文章链接：https://blog.csdn.net/lyh2004_08/article/details/149866401

**文章目录**

[TOC]


[LeetCode 199，二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/) ，【算数评级：4；通过率：71.5%】，这道题要求我们从二叉树的右侧观察，并按照从上到下的顺序，将能看到的节点值收集起来。它本质上是二叉树层序遍历（广度优先搜索 BFS）的一个变种

## 一、 题目描述

给定一个二叉树的根节点 `root` ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值

**示例:** 

**示例 1:** 
 ![示例 1](./assets/103_1.png)

```
输入: root = [1,2,3,null,5,null,4]
输出: [1,3,4]
解释:
从右侧看，第一层能看到 1
第二层能看到 3
第三层能看到 4
```

**示例 2:** 
 ![示例 2](./assets/103_2.png)

```
输入: root = [1,null,3]
输出: [1,3]
```

---

## 二、 核心思路：层序遍历(BFS) + 识别每层最右节点

要从右侧看树，并按层收集节点，这天然地提示我们使用 **层序遍历 (BFS)** 

当我们进行层序遍历时，我们是逐层从左到右访问节点的。那么，每一层的最后一个被访问的节点，显然就是我们从右侧能看到的那个节点

**具体步骤：** 

1.  **初始化** ：

   - 创建一个 `List<Integer>` 来存储最终结果

   - 创建一个 `Queue<TreeNode>` ，用于 BFS

2.  **起始** ：如果 `root` 不为空，将其加入队列

3.  **循环遍历** ：

   - 当队列不为空时，循环继续

   -  **获取当前层的节点数量** ：在每次循环开始时，记录下当前队列中元素的数量 `len = queue.size()` 

   -  **遍历当前层** ：使用一个 `for` 循环，迭代 `len` 次：

     - 从队列中取出一个节点 `node` 

     -  **判断是否为当前层的最右节点** ：如果当前节点是该层中最后一个被取出的节点（即 `i == len - 1` ），则将其值加入结果列表

     - 将 `node` 的左右孩子（如果存在）加入队列，为下一层做准备

---

## 三、 代码实现与深度解析

【层序遍历解法】

```java
class Solution {
    // 二叉树的右视图
    public List<Integer> rightSideView(TreeNode root) {
        ArrayList<Integer> res = new ArrayList<>(); // 存储结果

        // 如果根节点为空，直接返回空列表
        if (root == null) {
            return res;
        }

        Queue<TreeNode> queue = new LinkedList<>(); // 用于 BFS
        queue.add(root); // 将根节点加入队列

        // 当队列不为空时，循环继续
        while (!queue.isEmpty()) {
            int len = queue.size(); // 锁定当前层的节点数量
          
            // 遍历当前层的所有节点
            for (int i = 0; i < len; i++) {
                TreeNode node = queue.poll(); // 从队列头部取出节点
              
                // 判断是否是当前层的最后一个节点（即最右侧的节点）
                if (i == len - 1) {
                    res.add(node.val); // 将最右侧节点的值加入结果
                }

                // 将当前节点的左右孩子（如果存在）加入队列，为下一层做准备
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        return res;
    }
}
```

---

## 四、 关键点与复杂度分析

-  **BFS 的变体** ：本题是标准的层序遍历应用，通过巧妙地判断循环变量 `i` 来识别每层的最后一个节点

-  **`i == len - 1`** ：这是识别每层最右侧节点的关键条件。由于 BFS 是从左到右遍历每一层的，所以当 `i` 达到 `len - 1` 时，当前 `node` 就是该层最右侧的节点

-  **时间复杂度** ： **O(N)** 其中 N 是二叉树的节点数。每个节点都会被访问一次，并被加入和移出队列一次

-  **空间复杂度** ： **O(W)** 其中 W 是二叉树的最大宽度。在最坏情况下（例如，满二叉树的最后一层），队列中可能会存储大约 N/2 个节点，所以空间复杂度最坏为 O(N)

