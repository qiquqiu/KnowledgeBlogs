<p></p><br><div class="toc"><br> <h4>文章目录</h4><br> <ul><li><ul><li><a href="#_1">前言</a></li><li><a href="#_15">从图论角度理解并查集</a></li><li><ul><li><a href="#_17">基本概念</a></li><li><a href="#_32">图论视角下的并查集操作</a></li></ul><br>   </li><li><a href="#_58">并查集的核心功能</a></li><li><a href="#_66">★开箱即用的并查集模板</a></li><li><a href="#_197">关于路径压缩与按秩合并</a></li><li><ul><li><a href="#1__203">1. 路径压缩</a></li><li><a href="#2__248">2. 按秩合并</a></li></ul><br>   </li><li><a href="#_291">★实战秒杀案例</a></li><li><ul><li><a href="#1_1551_295">1. 洛谷1551题：亲戚</a></li><li><a href="#2_107_463">2. 卡码107题：寻找存在的路径</a></li><li><a href="#3_200_555">3. 力扣200题：岛屿数量</a></li><li><a href="#4_547_707">4. 力扣547题：省份数量</a></li><li><a href="#5_684_799">5. 力扣684题：冗余连接</a></li></ul><br>   </li><li><a href="#_886">题目对比分析表</a></li><li><ul><li><a href="#_896">共性特征分析</a></li><li><ul><li><a href="#1__898">1. 问题本质</a></li><li><a href="#2__904">2. 数据结构选择</a></li><li><a href="#3__913">3. 算法模式</a></li></ul><br>   </li></ul><br>   </li><li><a href="#_922">使用技巧与优化策略</a></li><li><ul><li><a href="#1__926">1. 坐标转换技巧</a></li><li><a href="#2__939">2. 矩阵对称性优化</a></li><li><a href="#3__954">3. 提前退出优化</a></li><li><a href="#4__966">4. 环检测模式</a></li><li><a href="#5__982">5. 预初始化策略</a></li></ul><br>   </li><li><a href="#_997">时间复杂度深度分析</a></li><li><ul><li><a href="#_n_999">阿克曼函数与反阿克曼函数 α(n)</a></li><li><a href="#_1019">各操作复杂度</a></li></ul><br>   </li><li><a href="#_1030">并查集的适用场景</a></li><li><ul><li><a href="#_1032">适合使用并查集的问题</a></li><li><a href="#_1039">不适合使用并查集的问题</a></li></ul><br>   </li><li><a href="#_1047">总结与扩充</a></li><li><ul><li><a href="#_1049">模板优势</a></li><li><a href="#_1055">实际应用价值</a></li><li><a href="#uu_1068">模板<u>性能极致</u>优化</a></li><li><ul><li><a href="#1__1072">1. 移除健壮性检查</a></li><li><a href="#2_uuHashMap_1076">2. 使用<u>数组</u>替代HashMap</a></li><li><a href="#3__1084">3. 实现按秩/大小合并进一步优化模板</a></li></ul><br>    </li><li><a href="#_vs__1151">泛型模板 vs 数组模板</a></li></ul><br>  </li></ul><br> </li></ul><br></div><br><p></p> <br><h3><a id="_1"></a>前言</h3> <br><p>并查集（Disjoint Set Union，DSU）是一种用于处理<strong>不相交集合合并和查询</strong>问题的数据结构。它主要用于解决<strong>连通性问题</strong>，当我们需要 <strong><u>判断两个元素是否在同一个集合里</u></strong> 的时候，就可以使用并查集。</p> <br><p>并查集在算法竞赛和实际开发中都有着广泛的应用，特别是在图论相关问题中表现出色。本文将从图论角度深入分析并查集的原理，并提供一个<strong>开箱即用的模板</strong>及其<strong>在各种题目中的实战应用</strong>。</p> <br><blockquote> <br> <p><strong>前置知识</strong>：图论基本概念，如顶点、边；<strong>连通分量</strong>，无向图，森林</p> <br> <p><strong>参考学习链接</strong>：<a href="https://oi-wiki.org/graph/concept/" rel="nofollow">图论基本概念 (OI Wiki)</a></p> <br> <p><strong>本文做的事情</strong>：</p> <br> <p>简单从图论角度回顾并查集原理，并且基于并查集的find、join等方法，实现两种不同且通用的<strong>并查集模板</strong>，并且直接用于 5 道题目的实战秒杀、讲解</p> <br></blockquote> <br><h3><a id="_15"></a>从图论角度理解并查集</h3> <br><h4><a id="_17"></a>基本概念</h4> <br><p>在图论中，并查集可以理解为维护一个<strong>动态连通图</strong>的数据结构：</p> <br><ul><li><strong>顶点（Vertex）</strong>：集合中的每个元素</li><li><strong>边（Edge）</strong>：元素之间的连接关系</li><li><strong>连通分量（Connected Component）</strong>：图中相互连通的顶点集合</li><li><strong>森林（Forest）</strong>：多个不相交的树组成的图结构</li></ul> <br><blockquote> <br> <p><strong>补充概念：连通分量</strong></p> <br> <p>在图论中，如果从顶点A可以到达顶点B（无论直接或间接），则称A和B是<strong>连通</strong>的。一个<strong>连通分量</strong>是图中的一个“最大”连通子图，其中任何两个顶点都相互连通，且它不与外部任何顶点连通。</p> <br> <p><strong>并查集与连通分量的关系</strong>：并查集中的每一个<strong>独立的集合</strong>，都完美对应了图论中的一个<strong>连通分量</strong>。<code>join(u, v)</code>操作就是将两个连通分量合并成一个，而<code>getComponentCount()</code>就是获取当前图中连通分量的总数。</p> <br></blockquote> <br><h4><a id="_32"></a>图论视角下的并查集操作</h4> <br><ol><li> <p><strong>初始状态</strong>：每个顶点都是一个独立的连通分量（自环）</p> <pre><code>1    2    3    4    5<br>↻   ↻    ↻    ↻   ↻<br></code></pre> </li><li> <p><strong>Union操作</strong>：连接两个连通分量，相当于在图中添加一条边</p> <pre><code>连接1和2后：<br>1 ← 2    3    4    5<br>    ↻   ↻    ↻    ↻<br></code></pre> </li><li> <p><strong>Find操作</strong>：寻找顶点所属连通分量的代表元素（根节点）</p> <pre><code>路径压缩前：1 ← 2 ← 3 ← 4<br>路径压缩后：1 ← 2<br>           ↑   ↑<br>           3   4<br></code></pre> </li></ol> <br><h3><a id="_58"></a>并查集的核心功能</h3> <br><ol><li><strong>将两个元素添加到一个集合中（Union操作）</strong></li><li><strong>判断两个元素在不在同一个集合（Find + 比较操作）</strong></li><li><strong>动态维护连通分量的数量</strong></li></ol> <br><hr /> <br><h3><a id="_66"></a>★开箱即用的并查集模板</h3> <br><p>基于并查集原理，我们可以封装一个通用并查集模板类，支持任意类型（泛型）的元素，以下是详细内容：</p> <br><pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span><span class="token punctuation">;</span><br><br><span class="token comment">/**<br> * 并查集模板类：基于HashMap实现的泛型并查集<br> * <br> * 核心思想：<br> * 1. 使用Map<T, T>存储父子关系，key为当前节点，value为父节点<br> * 2. 初始时每个节点的父节点是自己（自环），表示独立的连通分量<br> * 3. 通过路径压缩优化Find操作，使树保持扁平化<br> * 4. 实时维护连通分量数量，支持O(1)查询<br> * <br> * 要求：如无默认实现，则泛型T必须正确重写equals()和hashCode()方法<br> * <br> * 时间复杂度：<br> * - Find: O(α(n)) (近乎O(1)) （α为阿克曼函数的反函数）<br> * - Union: O(α(n)) (近乎O(1))<br> * - isConnected: O(α(n)) (近乎O(1))<br> * **注意**：严格来说，只有同时使用“路径压缩”和“按秩/大小合并”优化，时间复杂度才能达到O(α(n))。<br> * 本模板为了代码简洁和易用性，仅实现了路径压缩。<br> */</span><br><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token punctuation">{<!-- --></span><br>    <span class="token comment">// 存储父子关系的映射表：<当前节点, 父节点></span><br>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token punctuation">></span></span> father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <br>    <span class="token comment">// 连通分量的数量，初始为0</span><br>    <span class="token keyword">private</span> <span class="token keyword">int</span> componentCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br><br>    <span class="token comment">/**<br>     * 构造函数：创建空的并查集<br>     */</span><br>    <span class="token keyword">public</span> <span class="token class-name">DisjointSetUnion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 向并查集中添加一个新的顶点<br>     * <br>     * @param x 要添加的顶点<br>     * @return 如果顶点不存在则添加并返回true，否则返回false<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>father<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 实际刷题中，可以忽略这些健壮性判断，效率更高</span><br>            <span class="token comment">// 初始化时，每个节点的父节点是自己（形成自环）</span><br>            <span class="token comment">// 这表示该节点是一个独立的连通分量</span><br>            father<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><br>            componentCount<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 连通分量数量增加</span><br>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 顶点已存在</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 合并两个顶点所在的连通分量（Union操作）<br>     * <br>     * 在两个连通分量之间添加一条边，使它们合并为一个连通分量<br>     * <br>     * @param u 第一个顶点<br>     * @param v 第二个顶点<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token class-name">T</span> u<span class="token punctuation">,</span> <span class="token class-name">T</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 确保两个顶点都已添加到并查集中</span><br>        <span class="token comment">// 这样设计使得调用者无需预先添加所有顶点</span><br>        <span class="token function">add</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">add</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// 找到两个顶点所在连通分量的根节点</span><br>        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <br>        <span class="token comment">// 如果两个顶点不在同一个连通分量中</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>u<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token comment">// 将v的根节点指向u的根节点，实现合并</span><br>            <span class="token comment">// 这里选择u作为新的根节点（也可以选择v）</span><br>            father<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <br>            <span class="token comment">// 合并后连通分量数量减1</span><br>            componentCount<span class="token operator">--</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>        <span class="token comment">// 如果已经在同一个连通分量中，则无需操作</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 查找顶点所在连通分量的根节点（Find操作）<br>     * <br>     * 路径压缩<br>     * - 在查找过程中，将路径上的所有节点直接指向根节点<br>     * - 这样可以将树的高度压缩，提高后续查找效率<br>     * <br>     * @param x 要查找的顶点<br>     * @return 该顶点所在连通分量的根节点<br>     */</span><br>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 如果x不是根节点（即father[x] != x）</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token comment">// 递归查找根节点，同时进行路径压缩</span><br>            <span class="token comment">// 将x的父节点直接设置为根节点，跳过中间节点</span><br>            father<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token function">find</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>        <span class="token comment">// 返回根节点（可能是x本身，也可能是压缩后的根节点）</span><br>        <span class="token keyword">return</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 获取当前并查集中连通分量的数量<br>     * <br>     * @return 连通分量数量<br>     * 时间复杂度：O(1)<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getComponentCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">return</span> componentCount<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 判断两个顶点是否在同一个连通分量中<br>     * <br>     * @param u 第一个顶点<br>     * @param v 第二个顶点<br>     * @return 如果在同一个连通分量中返回true，否则返回false<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isConnected</span><span class="token punctuation">(</span><span class="token class-name">T</span> u<span class="token punctuation">,</span> <span class="token class-name">T</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 通过比较两个顶点的根节点是否相同来判断连通性</span><br>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><h3><a id="_197"></a>关于路径压缩与按秩合并</h3> <br><blockquote> <br> <p>直接看解题实操的，可跳过该原理分析部分，点击跳转下一标题：<strong><a href="#_291">实战秒杀题目</a></strong></p> <br></blockquote> <br><p>为了防止并查集在极端情况下退化成链表（导致Find操作复杂度变为O(n)），我们通常会采用两种核心优化策略：<strong>路径压缩</strong>和<strong>按秩合并</strong>。我们的<strong>模板中默认实现了路径压缩</strong>，这是最常用也是效果最显著的优化。</p> <br><h4><a id="1__203"></a>1. 路径压缩</h4> <br><p>路径压缩在<code>find</code>操作中实现，核心思想是：在查找一个节点的根节点时，将查找路径上所有节点都直接指向根节点。这极大地降低了树的高度，使得后续的查找操作变得非常快。</p> <br><p><strong>代码对比</strong></p> <br><p><strong>路径压缩<u>前</u>的 <code>find</code> 方法：</strong></p> <br><pre><code class="prism language-java"><span class="token comment">// 递归查找根节点，但不改变路径上节点的父指针</span><br><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">findWithoutCompression</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token class-name">T</span> current <span class="token operator">=</span> x<span class="token punctuation">;</span><br>    <span class="token comment">// 循环直到找到根节点（父节点是自己）</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        current <span class="token operator">=</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">return</span> current<span class="token punctuation">;</span><br><span class="token punctuation">}</span><br></code></pre> <br><ul><li><strong>缺点</strong>：如果树形成一条长链，每次<code>find</code>都需要遍历整条链，时间复杂度为O(n)。</li></ul> <br><p><strong>路径压缩<u>后</u>的 <code>find</code> 方法（模板采用）：</strong></p> <br><pre><code class="prism language-java"><span class="token comment">// 递归查找根节点，同时将路径上所有节点直接指向根节点</span><br><span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token class-name">T</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token comment">// 如果x的父节点不是自己，说明它不是根</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 递归查找根节点，并将x的父节点直接设置为根节点</span><br>        father<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token function">find</span><span class="token punctuation">(</span>father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token comment">// 返回根节点</span><br>    <span class="token keyword">return</span> father<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br></code></pre> <br><ul><li><strong>优势</strong>：一次查找后，树的高度被“压缩”，后续对路径上任一节点的查找都接近O(1)。</li></ul> <br><p><strong>图论意义</strong></p> <br><p>路径压缩将<strong>树的高度显著降低</strong>，使得所有非根节点都趋向于直接指向根节点，这样可以：</p> <br><ul><li><strong>极致优化查询效率</strong>：将<code>find</code>操作的均摊时间复杂度降至O(α(n))。</li><li><strong>保持树的“扁平化”</strong>：避免了链式结构的出现。</li><li><strong>不改变连通性</strong>：只改变内部指针，不影响任何节点所属的集合。</li></ul> <br><h4><a id="2__248"></a>2. 按秩合并</h4> <br><p>按秩合并是在<code>join</code>（或Union）操作中的一种优化策略，目的是在合并两个集合时，总是将“小”的树合并到“大”的树上，以避免树的高度不必要地增加。</p> <br><ul><li><strong>按秩（Rank）</strong>：基于树的高度。将高度较小的树合并到高度较大的树上。</li><li><strong>按大小（Size）</strong>：基于集合的节点数。将节点数较少的树合并到节点数较多的树上。（实现<strong>更简单</strong>，效果同样出色）</li></ul> <br><blockquote> <br> <ul><li>虽然<strong>我们的模板为了简洁易用没有默认实现按秩合并</strong>（仅路径压缩已经足够高效），虽然时间复杂度可能达不到后面分析的近似O(1)，但是综合考量使用方便和性能够用，我们仍按照最佳实践分析。</li><li>如文章开头所说，本文并非深入剖析并查集的各个方法的时间复杂度，而是提供一个通用且均衡的**“刷题向”模板**，<strong>简化解题思路</strong></li><li>不过结合了下方的“按大小合并的<code>join</code>方法实现示例”之后，大家也能轻松实现一个方法时间复杂度均接近 <strong>O(1)</strong> 的并查集模板</li></ul> <br></blockquote> <br><p>（补充内容，可跳过，直接看使用）下面是按大小合并的<code>join</code>方法实现示例：</p> <br><pre><code class="prism language-java"><span class="token comment">// 需要额外一个Map来存储每个集合的大小</span><br><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> size <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token comment">// 在add(x)时，初始化size.put(x, 1);</span><br><br><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token class-name">T</span> u<span class="token punctuation">,</span> <span class="token class-name">T</span> v<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token function">add</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">add</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token class-name">T</span> rootU <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token class-name">T</span> rootV <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rootU<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>rootV<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 按大小合并：将小树合并到大树上</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootU<span class="token punctuation">)</span> <span class="token operator"><</span> size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootV<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token class-name">T</span> temp <span class="token operator">=</span> rootU<span class="token punctuation">;</span><br>            rootU <span class="token operator">=</span> rootV<span class="token punctuation">;</span><br>            rootV <span class="token operator">=</span> temp<span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>        <span class="token comment">// 将v的根合并到u的根上</span><br>        father<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rootV<span class="token punctuation">,</span> rootU<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token comment">// 更新合并后集合的大小</span><br>        size<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rootU<span class="token punctuation">,</span> size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootU<span class="token punctuation">)</span> <span class="token operator">+</span> size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rootV<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        componentCount<span class="token operator">--</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><p><strong>组合效果</strong>：同时使用路径压缩和按秩合并，可以证明其时间复杂度为O(α(n))，在实践中近乎为常数时间O(1)，是性能最强的并查集实现。</p> <br><hr /> <br><h3><a id="_291"></a>★实战秒杀案例</h3> <br><blockquote> <br> <p>借助于上述<strong>并查集模板类</strong>，我们可以对下列题目进行<strong>非常直观</strong>的降维打击，稍加分析，使用正常智人思维即可轻松<strong>调用 api</strong> 解出！</p> <br></blockquote> <br><h4><a id="1_1551_295"></a>1. 洛谷1551题：亲戚</h4> <br><p><strong>题目链接</strong>：<a href="https://www.luogu.com.cn/problem/P1551" rel="nofollow">P1551 亲戚 - 洛谷</a></p> <br><p><strong>题目描述</strong></p> <br><p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p> <br><p>规定： a 和 b 是亲戚， b 和 c 是亲戚，那么 a 和 c 也是亲戚。如果 a, b 是亲戚，那么 a 的亲戚都是 b 的亲戚， b 的亲戚也都是 a 的亲戚。</p> <br><p><strong>输入格式</strong></p> <br><p>第一行：三个整数 n, m, p（1 <= n, m, p <= 5000），分别表示有 n 个人， m 个亲戚关系，询问 p 对亲戚关系。<br /> 以下 m 行：每行两个数 Mi, Mj（1 <= Mi, Mj <= n），表示 Mi 和 Mj 具有亲戚关系。<br /> 接下来 p 行：每行两个数 Pi, Pj，询问 Pi 和 Pj 是否具有亲戚关系。</p> <br><p><strong>输出格式</strong></p> <br><p>p 行，每行一个 <code>Yes</code> 或 <code>No</code>。表示第 i 个询问的答案为“具有”或“不具有”亲戚关系。</p> <br><p><strong>输入输出样例</strong></p> <br><p><strong>输入 #1</strong></p> <br><pre><code>6 5 3<br>1 2<br>1 5<br>3 4<br>5 2<br>1 3<br>1 4<br>2 3<br>5 6<br></code></pre> <br><p><strong>输出 #1</strong></p> <br><pre><code>Yes<br>Yes<br>No<br></code></pre> <br><p><strong>使用并查集思维</strong></p> <br><p>这个问题是并查集最直接、最经典的应用，完美诠释了其核心功能。</p> <br><p><strong>为什么使用并查集？</strong></p> <br><ul><li><strong>传递性</strong>：题目中“a和b是亲戚，b和c是亲戚，则a和c也是亲戚”的描述，完美地定义了一种<strong>等价关系</strong>。并查集正是为了维护这种具有传递性的等价关系而生的。所有在同一个集合中的元素，都满足这种等价关系，将这种关系抽象为图时，构成了一个<strong>无向图</strong>（众所周知，无向图是可以双向传递的，也就是关系的双向性），所以此刻天然契合<strong>使用并查集来秒杀</strong>。</li><li><strong>高效查询</strong>：对于大量的关系建立和存在性查询，并查集提供了近乎O(1)的均摊时间复杂度，远胜于其他如图遍历（每次查询都需要O(N+M)）等方法。</li></ul> <br><ol><li><strong>元素抽象</strong>：每个人（编号1到n）是并查集中的一个元素。</li><li><strong>关系抽象</strong>：一个“亲戚关系” <code>(Mi, Mj)</code> 意味着这两个人属于同一个“家族”。在并查集中，这对应着将 <code>Mi</code> 和 <code>Mj</code> 所在的集合进行合并（Union操作）。亲戚关系的传递性（a-b, b-c => a-c）正是通过并查集的合并操作来体现的：当a和b合并，b和c合并后，a, b, c都会在同一个集合中，有同一个根节点。</li><li><strong>查询抽象</strong>：询问两个人 <code>(Pi, Pj)</code> 是否有亲戚关系，就等价于查询他们是否属于同一个家族，即在并查集中他们是否在同一个集合里（<code>isConnected(Pi, Pj)</code>）。</li></ol> <br><p><strong>解题步骤</strong>：</p> <br><ol><li><strong>初始化</strong>：创建并查集，将 n 个人（1到n）分别添加进去，每个人自成一个家族。</li><li><strong>建立关系</strong>：读取 m 个亲戚关系，对每一对关系 <code>(Mi, Mj)</code>，执行 <code>join(Mi, Mj)</code>，将他们所在的家族合并。</li><li><strong>处理查询</strong>：读取 p 个查询，对每一对查询 <code>(Pi, Pj)</code>，执行 <code>isConnected(Pi, Pj)</code>。如果返回 <code>true</code>，则输出 <code>Yes</code>；否则输出 <code>No</code>。</li></ol> <br><p><strong>题解代码</strong></p> <br><blockquote> <br> <p>洛谷、卡码网等刷题不是力扣那样的核心代码模式，需要写Main类和main方法，以及自己导包</p> <br></blockquote> <br><pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span><span class="token punctuation">;</span><br><br><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main1551</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 使用“快读”而非Scanner，效率更高</span><br>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token comment">// n: 人数, m: 关系数, p: 查询数</span><br>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// 创建并查集</span><br>        <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> dsu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// 初始化，将所有n个人添加到并查集中，每个人初始时自成一个家族</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator"><=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            dsu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 读取m个亲戚关系，并合并相应的集合</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            split <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token keyword">int</span> person1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token keyword">int</span> person2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token comment">// 合并两个人的家族</span><br>            dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>person1<span class="token punctuation">,</span> person2<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 读取p个查询，并判断他们是否是亲戚</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> p<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            split <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token keyword">int</span> queryPerson1 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token keyword">int</span> queryPerson2 <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>            <span class="token comment">// 检查两个人是否在同一个集合中</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dsu<span class="token punctuation">.</span><span class="token function">isConnected</span><span class="token punctuation">(</span>queryPerson1<span class="token punctuation">,</span> queryPerson2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><p>基于 <strong>洛谷1551</strong> 引出的<strong>通用变式</strong>：</p> <br><p><strong>题目：给定 <code>n</code> 个人和 <code>m</code> 对朋友关系，问有多少个朋友圈（连通分量）？</strong></p> <br><p>有了上述的理解之后，这题也非常简单明了了，无非以下要点：</p> <br><ul><li>将每个<strong>人</strong>视为并查集中的一个<strong>元素/节点</strong>。</li><li>每对朋友<strong>关系</strong>视为连接两个元素的<strong>边</strong>。</li><li><strong>朋友圈</strong>即为并查集中的一个<strong>连通分量/独立集合</strong>。</li></ul> <br><blockquote> <br> <p><strong>流程简析：</strong></p> <br> <ol><li><strong>初始化：</strong> <br>   <ul><li>创建 n 个独立的集合，每个集合包含一个人。</li><li>初始化连通分量计数器 componentCount = n。</li></ul> </li><li><strong>处理朋友关系：</strong> <br>   <ul><li>对于每对朋友关系 (u, v)： <br>     <ul><li>查找 u 所在集合的代表元素（根）。</li><li>查找 v 所在集合的代表元素（根）。</li><li>如果 u 和 v 的根不同，说明他们目前不在同一个朋友圈，则将这两个集合<strong>合并</strong>。</li><li>合并后，连通分量计数器 componentCount 减 1。</li></ul> </li></ul> </li><li><strong>查找代表元素：</strong> <br>   <ul><li>find(x) 方法用于确定元素 x 属于哪个集合。</li><li>在查找过程中，执行<strong>路径压缩</strong>：将 x 及其路径上的所有节点直接<strong>连接到它们的最终根节点</strong>。这能极大地扁平化树结构，优化后续查询效率。</li></ul> </li></ol> <br></blockquote> <br><p><strong>完整题解：</strong></p> <br><pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> n <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 人数</span><br>        <span class="token keyword">int</span> m <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 朋友关系对数</span><br><br>        <span class="token comment">// 用人的编号表示人</span><br>        <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> dsu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator"><=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token comment">// 初始化人</span><br>            dsu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 录入关系数据</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 调 API，输出该并查集中有几个连通分量（由于使用了路径压缩，所以相当于找有几个根即可）</span><br>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dsu<span class="token punctuation">.</span><span class="token function">getComponentCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><h4><a id="2_107_463"></a>2. 卡码107题：寻找存在的路径</h4> <br><p><strong>题目链接</strong>：<a href="https://kamacoder.com/problempage.php?pid=1179" rel="nofollow">107. 寻找存在的路径 (kamacoder.com)</a></p> <br><p><strong>题目描述</strong></p> <br><p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。</p> <br><p><strong>输入描述</strong></p> <br><p>第一行包含两个正整数 N 和 M，N 代表节点的个数，M 代表边的个数。<br /> 后续 M 行，每行两个正整数 s 和 t，代表从节点 s 与节点 t 之间有一条边。<br /> 最后一行包含两个正整数，代表起始节点 source 和目标节点 destination。</p> <br><p><strong>输出描述</strong></p> <br><p>输出一个整数，代表是否存在从节点 source 到节点 destination 的路径。如果存在，输出 1；否则，输出 0。</p> <br><p><strong>输入示例</strong></p> <br><pre><code>5 4<br>1 2<br>1 3<br>2 4<br>3 4<br>1 4<br></code></pre> <br><p><strong>输出示例</strong></p> <br><pre><code>1<br></code></pre> <br><p><strong>使用并查集思维</strong></p> <br><p>这个问题本质上是判断<strong>图中的两个点是否连通</strong>。这正是并查集的经典应用场景。</p> <br><ol><li><strong>节点抽象</strong>：图中的每个节点（编号1到n）都可以看作是并查集中的一个元素。</li><li><strong>边的抽象</strong>：图中的每一条边 <code>(u, v)</code> 都意味着节点 <code>u</code> 和 <code>v</code> 是连通的。在并查集中，这对应着将 <code>u</code> 和 <code>v</code> 所在的集合进行合并（Union操作）。</li><li><strong>路径存在性判断</strong>：判断从 <code>source</code> 到 <code>destination</code> 是否存在路径，就等价于判断 <code>source</code> 和 <code>destination</code> 是否在同一个连通分量中。在并查集中，这对应着检查 <code>source</code> 和 <code>destination</code> 是否有共同的根节点（Find操作）。</li></ol> <br><p>通过处理所有的边，我们将所有直接或间接相连的节点都合并到同一个集合中。最后，只需要一次查询即可判断任意两点间的连通性。</p> <br><p><strong>题解代码</strong></p> <br><pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><br><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span><span class="token punctuation">;</span><br><br><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 比Scanner高效的“快读”法</span><br>        <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token comment">// 读取节点数N和边数M</span><br>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// 实例化并查集，Integer有默认的equals和hashCode，无需我们手动实现</span><br>        <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> dsu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token comment">// 初始化，将1到n的每个节点都作为一个独立的集合添加到并查集中</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator"><=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            dsu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 遍历所有边</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            split <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token comment">// 读取边的两个端点</span><br>            <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token comment">// 合并这两个端点所在的集合，表示它们是连通的</span><br>            dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 读取源节点和目标节点</span><br>        split <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> source <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> destination <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// 判断源和目标是否在同一个集合中</span><br>        <span class="token comment">// 如果是，则路径存在，输出1；否则输出0</span><br>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><br>        	dsu<span class="token punctuation">.</span><span class="token function">isConnected</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><br>        <span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><h4><a id="3_200_555"></a>3. 力扣200题：岛屿数量</h4> <br><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/number-of-islands/description/" rel="nofollow">200. 岛屿数量 - 力扣（LeetCode）</a></p> <br><p><strong>题目描述</strong></p> <br><p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p> <br><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p> <br><p>此外，你可以假设该网格的四条边均被水包围。</p> <br><p><strong>示例 1</strong></p> <br><pre><code>输入：grid = [<br>  ["1","1","1","1","0"],<br>  ["1","1","0","1","0"],<br>  ["1","1","0","0","0"],<br>  ["0","0","0","0","0"]<br>]<br>输出：1<br></code></pre> <br><p><strong>示例 2</strong></p> <br><pre><code>输入：grid = [<br>  ["1","1","0","0","0"],<br>  ["1","1","0","0","0"],<br>  ["0","0","1","0","0"],<br>  ["0","0","0","1","1"]<br>]<br>输出：3<br></code></pre> <br><p><strong>使用并查集思维</strong></p> <br><p>这个问题可以转化为计算图中<strong>连通分量</strong>的数量。</p> <br><ol><li><strong>节点抽象</strong>：网格中的每一块陆地（值为 <code>'1'</code> 的格子）都可以看作是图中的一个节点。</li><li><strong>边的抽象</strong>：如果两块陆地在水平或垂直方向上相邻，那么它们之间就存在一条边，表示它们是连通的。</li><li><strong>岛屿计数</strong>：一个岛屿就是由所有相互连接的陆地格子组成的集合。因此，岛屿的数量就等于图中连通分量的数量。</li></ol> <br><p><strong>解题步骤</strong>：</p> <br><ol><li><strong>初始化</strong>：创建一个并查集。初始时，连通分量的数量为0。</li><li><strong>遍历网格</strong>：遍历二维网格中的每个格子。</li><li><strong>处理陆地</strong>：当遇到一个陆地格子 <code>(i, j)</code> 时： <br>  <ul><li>首先，将这个陆地格子自身视为一个独立的连通分量（如果它尚未被添加），并查集中的连通分量总数加1。</li><li>然后，检查它的上方和左方（或下方和右方，选择两个方向即可避免重复）的相邻格子。如果相邻格子也是陆地，就将当前陆地格子与相邻陆地格子在并查集中进行合并（Union操作）。如果合并成功（即它们原本不属于同一个连通分量），则并查集中的连通分量总数减1。</li></ul> </li><li><strong>返回结果</strong>：遍历完整个网格后，并查集中维护的连通分量数量就是最终的岛屿数量。</li></ol> <br><p><strong>技巧优化</strong>：为了在并查集中<strong>唯一标识</strong>每个格子，需要将二维坐标 <code>(i, j)</code> <strong>映射</strong>到一个一维的整数ID，例如 <code>id = i * m + j</code>（其中 <code>m</code> 是网格的列数）。</p> <br><p><strong>题解代码</strong></p> <br><pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token comment">// 并查集实例，用于维护陆地格子的连通关系</span><br>    <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> dsu<span class="token punctuation">;</span><br>    <span class="token comment">// 网格的行数和列数</span><br>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><br><br>    <span class="token comment">/**<br>     * 主函数，计算岛屿数量<br>     * @param grid 二维网格，'1'为陆地，'0'为水<br>     * @return 岛屿数量<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        dsu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        n <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>        m <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><br><br>        <span class="token comment">// 遍历网格中的每个格子</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator"><</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token comment">// 如果当前格子是陆地</span><br>                <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                    <span class="token comment">// 将当前陆地格子添加到并查集中，如果它不存在，连通分量数会加1</span><br>                    dsu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">calId</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                    <span class="token comment">// 检查并合并相邻的陆地</span><br>                    <span class="token comment">// 只检查下方和右方，避免重复检查</span><br>                    <span class="token comment">// 检查下方</span><br>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator"><</span> n <span class="token operator">&&</span> grid<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                        dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token function">calId</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">calId</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                    <span class="token punctuation">}</span><br>                    <span class="token comment">// 检查右方</span><br>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator"><</span> m <span class="token operator">&&</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                        dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token function">calId</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">calId</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>                    <span class="token punctuation">}</span><br>                <span class="token punctuation">}</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 最终并查集中的连通分量数量即为岛屿数量</span><br>        <span class="token keyword">return</span> dsu<span class="token punctuation">.</span><span class="token function">getComponentCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 将二维坐标 (i, j) 转换为一维的唯一ID<br>     * @param i 行坐标<br>     * @param j 列坐标<br>     * @return 唯一ID<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calId</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">return</span> i <span class="token operator">*</span> m <span class="token operator">+</span> j<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><p>注：该题使用 <strong>dfs</strong> 也同样简单直观 <strong>↓</strong></p> <br><pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> ans<span class="token punctuation">;</span><br>    <span class="token keyword">static</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited<span class="token punctuation">;</span><br><br>    <span class="token comment">// 普通dfs解法</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        n <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>        m <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><br><br>        visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator"><</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&&</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                    ans<span class="token operator">++</span><span class="token punctuation">;</span><br>                    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token punctuation">}</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">// 计算岛屿数量</span><br>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator"><</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> j <span class="token operator"><</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> m <span class="token operator">||</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'1'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token keyword">return</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br><br>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><h4><a id="4_547_707"></a>4. 力扣547题：省份数量</h4> <br><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/number-of-provinces/description/" rel="nofollow">547. 省份数量 - 力扣（LeetCode）</a></p> <br><p><strong>题目描述</strong></p> <br><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p> <br><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p> <br><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i] [j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i] [j] = 0 表示二者不直接相连。</p> <br><p>返回矩阵中 省份 的数量。</p> <br><p><strong>示例 1</strong></p> <br><p><img src="https://i-blog.csdnimg.cn/img_convert/b795a9d3f99733da8da93eed653a8aad.jpeg" alt="图1" /></p> <br><pre><code>输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]<br>输出：2<br></code></pre> <br><p><strong>示例 2</strong></p> <br><p><img src="https://i-blog.csdnimg.cn/img_convert/98c6e09f71949b3373a2db6383c06f45.jpeg" alt="图2" /></p> <br><pre><code>输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]<br>输出：3<br></code></pre> <br><p><strong>使用并查集思维</strong></p> <br><p>这个问题是“岛屿数量”问题的变体，同样是计算图的连通分量数量。</p> <br><p><strong>与dfs/bfs对比</strong>：</p> <br><ul><li><strong>dfs/bfs</strong>：通过遍历找到一个未访问的城市，然后深入或广度优先地访问所有与之相连的城市，并标记为已访问。每启动一次新的遍历，就意味着发现了一个新的省份。这种方法直观，易于理解。</li><li><strong>并查集</strong>：将每个城市视为一个独立的集合。遍历邻接关系，不断合并属于同一省份的城市。最后统计集合的数量。并查集的优势在于其“合并”操作的效率极高，对于处理动态连通性问题或关系合并非常有效。对于本题，两种方法复杂度相似，但并查集提供了一个不同的、基于“集合”的视角。</li></ul> <br><ol><li><strong>节点抽象</strong>：每个城市（编号从 0 到 n-1）是图中的一个节点，对应并查集中的一个元素。</li><li><strong>边的抽象</strong>：邻接矩阵 <code>isConnected[i][j] = 1</code> 表示城市 <code>i</code> 和城市 <code>j</code> 之间有一条直接连接的边。这对应于在并查集中合并 <code>i</code> 和 <code>j</code>。</li><li><strong>省份计数</strong>：一个“省份”就是图中的一个连通分量。因此，省份的数量就是最终并查集中集合的数量。</li></ol> <br><p><strong>解题步骤</strong>：</p> <br><ol><li><strong>初始化</strong>：创建一个并查集，并将 n 个城市（0 到 n-1）分别作为独立的集合添加进去。此时，连通分量（省份）的数量为 n。</li><li><strong>遍历邻接矩阵</strong>：遍历 <code>isConnected</code> 矩阵的上半部分（因为 <code>isConnected[i][j] == isConnected[j][i]</code>，遍历一半即可）。</li><li><strong>合并城市</strong>：当发现 <code>isConnected[i][j] == 1</code> 时，表示城市 <code>i</code> 和 <code>j</code> 直接相连。此时，在并查集中执行 <code>join(i, j)</code> 操作。如果 <code>i</code> 和 <code>j</code> 原本不属于同一个省份，合并后省份总数会减1。</li><li><strong>返回结果</strong>：遍历完整个邻接矩阵后，并查集中剩余的连通分量数量就是省份的总数。</li></ol> <br><p><strong>题解代码</strong></p> <br><pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token comment">/**<br>     * 计算省份数量<br>     * @param isConnected 邻接矩阵，表示城市间的连接关系<br>     * @return 省份数量<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findCircleNum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> isConnected<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 城市数量</span><br>        <span class="token keyword">int</span> n <span class="token operator">=</span> isConnected<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>        <span class="token comment">// 实例化并查集</span><br>        <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> dsu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// 初始化，每个城市最初都是一个独立的省份</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            dsu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 遍历邻接矩阵的上半部分来建立连接关系</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token comment">// j从i+1开始，避免重复遍历和处理对角线</span><br>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator"><</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token comment">// 如果两个城市直接相连</span><br>                <span class="token keyword">if</span> <span class="token punctuation">(</span>isConnected<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                    <span class="token comment">// 则将它们合并到同一个省份（集合）中</span><br>                    dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span><br>                <span class="token punctuation">}</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 最终的连通分量数就是省份数</span><br>        <span class="token keyword">return</span> dsu<span class="token punctuation">.</span><span class="token function">getComponentCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><blockquote> <br> <p>此题的dfs，bfs解法代码略</p> <br></blockquote> <br><h4><a id="5_684_799"></a>5. 力扣684题：冗余连接</h4> <br><p><strong>题目链接</strong>：<a href="https://leetcode.cn/problems/redundant-connection/description/" rel="nofollow">684. 冗余连接 - 力扣（LeetCode）</a></p> <br><p><strong>题目描述</strong></p> <br><p>树可以看成是一个连通且 无环 的 无向 图。</p> <br><p>给定一个图，该图从一棵 n 个节点 (节点值 1～n) 的树中添加一条边后获得。添加的边的两个不同顶点编号在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p> <br><p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的那个。</p> <br><p><strong>示例 1</strong></p> <br><p><img src="https://i-blog.csdnimg.cn/img_convert/915eb15b8b2f7c8e87af324ffdef8202.png" alt="图1" /></p> <br><pre><code>输入: edges = [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br></code></pre> <br><p><strong>示例 2</strong></p> <br><p><img src="https://i-blog.csdnimg.cn/img_convert/bb2e8146d9dc0a57867017083850b6ab.png" alt="图2" /></p> <br><pre><code>输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>输出: [1,4]<br></code></pre> <br><p><strong>使用并查集思维</strong></p> <br><p>这个问题的核心是<strong>在图中检测环</strong>。一条边之所以“冗余”，是因为它连接了两个本就已经连通的节点，从而形成了一个环。</p> <br><p><strong>解题思路深度剖析</strong>：</p> <br><ul><li><strong>树的特性</strong>：一棵包含n个节点的树，有且仅有n-1条边，并且图中无环。</li><li><strong>冗余边的本质</strong>：当一个图有n个节点和n条边时，它必然包含至少一个环。这条导致成环的“多余”的边就是冗余连接。</li><li><strong>并查集的作用</strong>：并查集是检测环的利器。当我们遍历边列表，尝试将边的两个端点<code>u</code>和<code>v</code>加入集合时，如果<code>u</code>和<code>v</code>在加入前就已经属于同一个集合（<code>isConnected(u,v)</code>为<code>true</code>），说明图中已经存在一条从<code>u</code>到<code>v</code>的路径。此时再加入边<code>(u,v)</code>，就会形成一个闭合的环路。因此，这条边就是冗-余的。</li></ul> <br><ol><li><strong>节点抽象</strong>：图中的每个节点（1到n）是并查集中的一个元素。</li><li><strong>边的处理</strong>：我们按顺序遍历 <code>edges</code> 数组中的每一条边 <code>(u, v)</code>。</li><li><strong>环的检测</strong>：在处理边 <code>(u, v)</code> <strong>之前</strong>，我们先用并查集检查 <code>u</code> 和 <code>v</code> 是否已经连通（即 <code>isConnected(u, v)</code>）。 <br>  <ul><li><strong>如果 <code>u</code> 和 <code>v</code> 已经连通</strong>：说明在 <code>u</code> 和 <code>v</code> 之间已经存在一条路径。此时再加入边 <code>(u, v)</code>，必然会形成一个环。因此，这条边 <code>(u, v)</code> 就是我们要找的冗余连接。</li><li><strong>如果 <code>u</code> 和 <code>v</code> 尚未连通</strong>：说明这条边是连接两个不同连通分量的“桥”，不会形成环。我们应该将它加入图中，即在并查集中执行 <code>join(u, v)</code> 操作。</li></ul> </li></ol> <br><p>因为题目要求返回最后出现的冗余边，所以我们只需按顺序遍历，找到的第一条导致成环的边就是答案（如果有多条，最后一条被判断为冗余的边会覆盖前面的结果）。</p> <br><p><strong>题解代码</strong></p> <br><pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token comment">/**<br>     * 寻找冗余连接<br>     * @param edges 图的边列表<br>     * @return 导致成环的冗余边<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findRedundantConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 实例化并查集</span><br>        <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> dsu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DisjointSetUnion</span><span class="token generics"><span class="token punctuation"><</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br>        <span class="token comment">// 遍历每一条边</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token keyword">int</span> u <span class="token operator">=</span> edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>            <span class="token keyword">int</span> v <span class="token operator">=</span> edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br>            <span class="token comment">// 在处理这条边之前，检查它的两个端点是否已经连通</span><br>            <span class="token comment">// 注意：我们的模板在join时会自动add节点，所以这里可以不显式调用add</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dsu<span class="token punctuation">.</span><span class="token function">isConnected</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token comment">// 如果已经连通，说明添加这条边会形成环</span><br>                <span class="token comment">// 因此，这条边就是冗余的</span><br>                <span class="token comment">// 根据题意，返回最后出现的冗余边，所以直接返回当前边即可</span><br>                <span class="token keyword">return</span> edge<span class="token punctuation">;</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token comment">// 如果不连通，则这是一条有效的树边，将它们合并</span><br>                dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br><br>        <span class="token comment">// 根据题目保证，一定存在冗余连接，所以理论上不会执行到这里</span><br>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><hr /> <br><h3><a id="_886"></a>题目对比分析表</h3> <br><table><thead><tr><th>题目</th><th>问题类型</th><th>核心操作</th><th>关键技巧</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>洛谷1551</td><td>关系查询</td><td>isConnected</td><td>传递性关系建模</td><td>O((m+p)·α(n)) (近乎<strong>O(m+p)</strong>)</td><td>O(n)</td></tr><tr><td>卡码107</td><td>路径存在性</td><td>isConnected</td><td>预初始化所有节点</td><td>O(m·α(n)) (近乎<strong>O(m)</strong>)</td><td>O(n)</td></tr><tr><td>LC200</td><td>连通分量计数</td><td>getComponentCount</td><td>二维坐标映射</td><td>O(mn·α(mn)) (近乎<strong>O(mn)</strong>)</td><td>O(mn)</td></tr><tr><td>LC547</td><td>连通分量计数</td><td>getComponentCount</td><td>矩阵对称性优化</td><td>O(n²·α(n)) (近乎<strong>O(n²)</strong>)</td><td>O(n)</td></tr><tr><td>LC684</td><td>环检测</td><td>isConnected + join</td><td>添加前检查连通性</td><td>O(n·α(n)) (近乎<strong>O(n)</strong>)</td><td>O(n)</td></tr></tbody></table><br><h4><a id="_896"></a>共性特征分析</h4> <br><h5><a id="1__898"></a>1. 问题本质</h5> <br><p>所有题目的核心都是<strong>图的连通性问题</strong>：</p> <br><ul><li><strong>静态查询</strong>：判断两点是否连通（卡码107、洛谷1551）</li><li><strong>动态计数</strong>：统计连通分量数量（LC200、LC547）</li><li><strong>环检测</strong>：检测边的添加是否形成环（LC684）</li></ul> <br><h5><a id="2__904"></a>2. 数据结构选择</h5> <br><p>所有题目都选择并查集的原因：</p> <br><blockquote> <br> <p>当然并不代表其他解法，如：dfs 等行不通，相反，在有些题目中 dfs 反而更加高效，例如力扣200；只不过使用模板更加无脑简单，如上述所有代码逻辑，无需复杂递归设计，只需宏观上将问题向“连通分量”、“连通性”等方向思考、转移即可。</p> <br></blockquote> <br><ul><li><strong>高效合并</strong>：O(α(n)) 时间复杂度合并两个集合</li><li><strong>快速查询</strong>：O(α(n)) 时间复杂度判断连通性</li><li><strong>实时维护</strong>：动态维护连通分量信息</li></ul> <br><h5><a id="3__913"></a>3. 算法模式</h5> <br><pre><code>1. 初始化并查集<br>2. 处理连接关系（边）<br>3. 执行查询操作<br></code></pre> <br><hr /> <br><h3><a id="_922"></a>使用技巧与优化策略</h3> <br><p>上述几题中，有些使用了一些技巧或优化，经过这些技巧的转换，让使用并查集变得更加自然且流畅</p> <br><h4><a id="1__926"></a>1. 坐标转换技巧</h4> <br><p><strong>适用场景</strong>：二维网格问题（如LC200）</p> <br><pre><code class="prism language-java"><span class="token comment">// 将二维坐标(i,j)转换为一维唯一ID（类似取 hashCode 的思想，方式非唯一）</span><br><span class="token keyword">int</span> id <span class="token operator">=</span> i <span class="token operator">*</span> cols <span class="token operator">+</span> j<span class="token punctuation">;</span><br></code></pre> <br><p><strong>优势</strong>：</p> <br><ul><li>避免使用复杂的二维坐标作为键</li><li>提高HashMap的查找效率</li><li>节省内存空间</li></ul> <br><h4><a id="2__939"></a>2. 矩阵对称性优化</h4> <br><p><strong>适用场景</strong>：邻接矩阵表示的无向图（如LC547）</p> <br><pre><code class="prism language-java"><span class="token comment">// 只遍历上三角矩阵</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator"><</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token comment">// 处理边(i,j)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><p><strong>优势</strong>：</p> <br><ul><li>减少一半的遍历次数</li><li>避免重复处理同一条边</li></ul> <br><h4><a id="3__954"></a>3. 提前退出优化</h4> <br><p><strong>适用场景</strong>：当达到特定条件时可以提前结束（如LC547）</p> <br><pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>dsu<span class="token punctuation">.</span><span class="token function">getComponentCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 所有节点已连通</span><br><span class="token punctuation">}</span><br></code></pre> <br><p><strong>优势</strong>：</p> <br><ul><li>在最优情况下显著提升性能</li><li>避免不必要的计算</li></ul> <br><h4><a id="4__966"></a>4. 环检测模式</h4> <br><p><strong>适用场景</strong>：需要检测图中环的存在（如LC684）</p> <br><pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>dsu<span class="token punctuation">.</span><span class="token function">isConnected</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token comment">// 添加边(u,v)会形成环</span><br>    <span class="token keyword">return</span> edge<span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><br>    dsu<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br></code></pre> <br><p><strong>优势</strong>：</p> <br><ul><li>实时检测环的形成</li><li>避免构建完整图后再检测</li></ul> <br><h4><a id="5__982"></a>5. 预初始化策略</h4> <br><p><strong>适用场景</strong>：节点数量已知的情况（如卡码107、洛谷1551）</p> <br><pre><code class="prism language-java"><span class="token comment">// 预先添加所有节点</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator"><=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>    dsu<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br></code></pre> <br><p><strong>优势</strong>：</p> <br><ul><li>避免join操作中的重复检查</li><li>提高代码的可读性和性能</li></ul> <br><hr /> <br><h3><a id="_997"></a>时间复杂度深度分析</h3> <br><blockquote> <br> <h4><a id="_n_999"></a>阿克曼函数与反阿克曼函数 α(n)</h4> <br> <p><strong>这是什么?</strong></p> <br> <ul><li><strong>阿克曼函数</strong>：一个增长速度极快的递归函数，它的值增长速度远超指数、阶乘等任何我们熟知的函数。对于很小的输入，其输出就大到无法想象。</li><li><strong>反阿克曼函数 α(n)</strong>：阿克曼函数的反函数，因此它的增长速度<strong>极其缓慢</strong>。</li></ul> <br> <p><strong>和并查集有什么关系?</strong><br /> 经过路径压缩和按秩合并优化的并查集，其<code>find</code>和<code>join</code>操作的平均时间复杂度被证明为 <strong>O(α(n))</strong>，参考：<a href="https://oi-wiki.org/ds/dsu-complexity/" rel="nofollow">并查集复杂度 - OI Wiki (oi-wiki.org)</a></p> <br> <p><strong>为什么可以近似看作 O(1)?</strong><br /> 因为 α(n) 的增长实在是太慢了。在计算机科学能处理的任何问题规模 n 中（例如，n 小于宇宙中所有原子的数量），α(n) 的值都不会超过 5。因此，在实践中，我们可以放心地将其视为一个<strong>极小的常数</strong>，时间复杂度近似为 <strong>O(1)</strong>。</p> <br> <p><strong>相关知识链接</strong>:</p> <br> <ul><li><a href="https://blog.csdn.net/niu1024/article/details/111771824">阿克曼函数详解 (CSDN博客)</a></li><li><a href="https://www.cnblogs.com/shiys22/p/17766893.html" rel="nofollow">并查集复杂度与反阿克曼函数 (博客园)</a></li><li>https://blog.csdn.net/lemonoil/article/details/57085830</li></ul> <br></blockquote> <br><h4><a id="_1019"></a>各操作复杂度</h4> <br><table><thead><tr><th>操作</th><th>未优化</th><th>仅路径压缩</th><th>仅按秩合并</th><th>路径压缩 + 按秩合并</th></tr></thead><tbody><tr><td><code>find</code></td><td>O(n)</td><td>O(log n)</td><td>O(log n)</td><td>O(α(n)) (近乎O(1))</td></tr><tr><td><code>join</code></td><td>O(n)</td><td>O(log n)</td><td>O(log n)</td><td>O(α(n)) (近乎O(1))</td></tr><tr><td><code>isConnected</code></td><td>O(n)</td><td>O(log n)</td><td>O(log n)</td><td>O(α(n)) (近乎O(1))</td></tr><tr><td><code>getComponentCount</code></td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(1) 直接返回计数器</td></tr></tbody></table><br><hr /> <br><h3><a id="_1030"></a>并查集的适用场景</h3> <br><h4><a id="_1032"></a>适合使用并查集的问题</h4> <br><ol><li><strong>动态连通性查询</strong>：需要频繁查询两点是否连通</li><li><strong>连通分量计数</strong>：需要实时维护<strong>连通分量</strong>数量</li><li><strong>环检测</strong>：在图的构建过程中检测环</li><li><strong>等价关系处理</strong>：处理具有传递性的关系</li><li><strong>最小生成树算法</strong>：Kruskal算法的核心组件</li></ol> <br><h4><a id="_1039"></a>不适合使用并查集的问题</h4> <br><ol><li><strong>路径查询</strong>：需要找到两点间的具体路径</li><li><strong>最短路径</strong>：需要计算两点间的最短距离</li><li><strong>图的遍历</strong>：需要按特定顺序访问节点</li><li><strong>动态删除边</strong>：并查集不支持高效的边删除</li></ol> <br><hr /> <br><h3><a id="_1047"></a>总结与扩充</h3> <br><h4><a id="_1049"></a>模板优势</h4> <br><ol><li><strong>通用性强</strong>：泛型设计，支持<strong>任意类型</strong>元素；刷题中一般 int 多见</li><li><strong>性能卓越</strong>：路径压缩优化，接近 <strong>O(1)</strong> 操作</li><li><strong>功能完整</strong>：提供连通分量计数等高级功能</li><li><strong>易于使用</strong>：API简洁，学习成本低；上手直接无脑手戳，或者Ctrl C V大法再说</li></ol> <br><h4><a id="_1055"></a>实际应用价值</h4> <br><ul><li><strong>算法竞赛</strong>：快速解决连通性相关问题</li><li><strong>系统设计</strong>：网络连通性检测、用户关系分析</li><li><strong>数据处理</strong>：大规模数据的分组和聚类</li><li><strong>图算法</strong>：作为其他复杂图算法的基础组件</li></ul> <br><p>在刷题过程中，遇到<strong>连通性问题</strong>时，可以直接使用这个模板，大大提高解题效率。<br /> 特别适用于图论中的连通分量、最小生成树、动态连通性等问题。掌握并查集不仅能解决特定类型的题目，更能加深对图论和数据结构的理解。</p> <br><blockquote> <br> <p>但是<strong>注意</strong>：</p> <br> <ul><li><strong>dfs+递归</strong>等老方法固然是<strong>基本功</strong>，需要完全掌握，但是<strong>并查集的解法</strong>更算是一种进阶解法，某些情况下极其好用。</li><li>不要为了使用模板而使用模板，有时候借助显然的递归反而能更加轻松且高效解题，以免南辕北辙。</li></ul> <br></blockquote> <br><h4><a id="uu_1068"></a>模板<u>性能极致</u>优化</h4> <br><p>虽然我们提供的泛型模板通用性强且足够高效，但在对性能要求极为苛刻的场景（如算法竞赛），还可以进行以下优化：</p> <br><h5><a id="1__1072"></a>1. 移除健壮性检查</h5> <br><p>模板中的<code>add</code>方法包含了<code>father.containsKey(x)</code>检查，以防止重复添加和保证程序的健壮性。但在竞赛中，通常可以<strong>确保输入数据的有效性</strong>（例如，节点编号在给定范围内且不重复）。此时，可以移除这些检查，由调用者自己保证初始化的正确性，从而省去一部分哈希查找的开销。</p> <br><h5><a id="2_uuHashMap_1076"></a>2. 使用<u>数组</u>替代HashMap</h5> <br><p>当并查集处理的元素是<strong>从0或1开始的连续整数</strong>时，使用数组是比<code>HashMap</code><strong>更高效</strong>的选择。这可以完全避免<code>HashMap</code>的<strong>哈希计算开销</strong>以及泛型带来的装箱/拆箱成本。</p> <br><blockquote> <br> <p>HashMap 底层虽然也是数组实现，但是当 HashMap 的底层数组达到一定程度的时候，会进行<strong>扩容</strong>，这将一定程度上降低效率。（参考：<a href="https://blog.csdn.net/lyh2004_08/article/details/149148936">关于HashMap扩容</a>）</p> <br> <p>但是对于大部分的网站刷题来说，使用上述模板已经足够了。</p> <br></blockquote> <br><h5><a id="3__1084"></a>3. 实现按秩/大小合并进一步优化模板</h5> <br><blockquote> <br> <p>参考“路径压缩”与“按秩/大小合并”优化算法时间复杂度：<strong><a href="#_197">按秩/大小合并</a></strong></p> <br></blockquote> <br><p><strong><u>数组</u>实现等价模板</strong>：</p> <br><pre><code class="prism language-java"><span class="token comment">/**<br> * 并查集模板类（数组实现）<br> * 适用于元素是连续整数（如 0 到 n-1）的场景<br> */</span><br><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DisjointSetUnionInt</span> <span class="token punctuation">{<!-- --></span><br>    <span class="token comment">// 存储父节点的数组，father[i]表示i的父节点</span><br>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> father<span class="token punctuation">;</span><br>    <span class="token comment">// 连通分量的数量</span><br>    <span class="token keyword">private</span> <span class="token keyword">int</span> componentCount<span class="token punctuation">;</span><br><br>    <span class="token comment">/**<br>     * 构造函数<br>     * @param n 元素总数（编号从0到n-1）<br>     */</span><br>    <span class="token keyword">public</span> <span class="token class-name">DisjointSetUnionInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><br>        <span class="token keyword">this</span><span class="token punctuation">.</span>componentCount <span class="token operator">=</span> n<span class="token punctuation">;</span><br>        <span class="token comment">// 初始化，每个元素的父节点都是自己</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 查找元素i所在集合的根节点（带路径压缩）<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>father<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 路径压缩</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">return</span> father<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 合并元素i和j所在的集合<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        i<span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        j <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            father<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 将j的根指向i的根</span><br>            componentCount<span class="token operator">--</span><span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 判断两个元素是否在同一个集合中<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isConnected</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><br>    <span class="token comment">/**<br>     * 获取当前连通分量的数量<br>     */</span><br>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getComponentCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">return</span> componentCount<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br></code></pre> <br><h4><a id="_vs__1151"></a>泛型模板 vs 数组模板</h4> <br><p><strong>核心思想一致</strong>：无论是泛型模板还是数组模板，其底层实现的<strong>并查集原理是完全等价的</strong>。</p> <br><p>它们都依赖于<code>father</code>数据结构来维护父子关系，并通过<code>find</code>（路径压缩）和<code>join</code>操作来管理集合。区别仅在于数据存储方式和适用场景。</p> <br><table><thead><tr><th align="left"></th><th align="left">泛型模板 (DisjointSetUnion)</th><th align="left">数组模板 (DisjointSetUnionInt)</th></tr></thead><tbody><tr><td align="left"><strong>通用性</strong></td><td align="left"><strong>极高</strong>。支持任何对象类型（字符串、自定义类等），只要正确实现<code>equals</code>和<code>hashCode</code>。</td><td align="left"><strong>有限</strong>。仅适用于从0或1开始的连续整数。</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left"><strong>高</strong>。但有<code>HashMap</code>的哈希计算和泛型装箱/拆箱的开销。</td><td align="left"><strong>极致</strong>。直接进行数组索引，无任何额外开销。</td></tr><tr><td align="left"><strong>内存开销</strong></td><td align="left"><strong>较大</strong>。<code>HashMap</code>需要存储键、值、哈希码和链表/红黑树指针。</td><td align="left"><strong>较小</strong>。仅需一个<code>int</code>数组的内存空间。</td></tr><tr><td align="left"><strong>初始化</strong></td><td align="left"><strong>动态</strong>。可以随时通过 add 或 join 方法加入新元素，无需预先知道总数。</td><td align="left"><strong>静态</strong>。需要预先知道元素总数 n，一次性分配所有内存。</td></tr><tr><td align="left"><strong>选择建议</strong></td><td align="left">- <strong>首选</strong>：当处理非整数、离散或未知范围的元素时。<br />- <strong>便利性</strong>：代码更灵活，无需手动进行元素到索引的映射</td><td align="left">- <strong>首选</strong>：在性能要求极高的竞赛或场景中，且元素是连续整数。<br />- <strong>效率</strong>：追求极致的运行速度和最小的内存占用。</td></tr></tbody></table>